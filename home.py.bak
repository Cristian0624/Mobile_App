from kivy.app import App
from kivy.uix.screenmanager import Screen, SlideTransition
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.button import Button
from kivy.uix.label import Label
from kivy.graphics import Color, Rectangle, RoundedRectangle, Ellipse, Line
from kivy.graphics import StencilPush, StencilUse, StencilUnUse, StencilPop
from kivy.metrics import dp
from kivy.uix.floatlayout import FloatLayout
from kivy.uix.anchorlayout import AnchorLayout
from kivy.uix.widget import Widget
from kivy.uix.behaviors import ButtonBehavior, ToggleButtonBehavior
from kivy.properties import StringProperty, BooleanProperty, ObjectProperty
from kivy.uix.image import Image
from kivy.core.window import Window
from kivy.uix.spinner import Spinner
from kivy.uix.scrollview import ScrollView
from kivy.uix.gridlayout import GridLayout
from kivy.uix.textinput import TextInput
from kivy.clock import Clock
from datetime import datetime, timedelta
import os
import threading
import math
from round_button import RoundButton
from theme_manager import ThemeManager
from kivy.uix.relativelayout import RelativeLayout
from kivy.uix.switch import Switch
from kivy.uix.dropdown import DropDown
from database import UserDatabase  # Updated import
from kivy.uix.filechooser import FileChooserListView
from kivy.uix.popup import Popup
import json
import uuid
from circular_button import CircularButton
from kivy.uix.image import AsyncImage

# Define language settings
LANGUAGES = ['en', 'ro', 'ru']
CURRENT_LANGUAGE = {'lang': 'en'}  # Default language

# Translation dictionaries
LANG_DICT = {
    'en': {
        'login': 'Login',
        'username': 'Username',
        'password': 'Password',
        'register': 'Register',
        'home_page': 'Home',
        'welcome': 'Welcome',
        'settings': 'Settings',
        'notifications': 'Notifications',
        'dark_mode': 'Dark Mode',
        'sound': 'Sound',
        'vibration': 'Vibration',
        'language': 'Language',
        'logout': 'Logout',
        'add': 'ADD',
        'no_reminders_yet': 'No antibiotic reminders yet.\nTap + to create a new reminder.',
        'ready': 'READY',
        'due_now': 'DUE NOW',
        'minutes': 'min',
        'taken': 'TAKEN',
        'take_now': 'TAKE NOW',
        'delete': 'Delete',
        'edit': 'Edit',
        'ask_ai_assistant': 'Ask AI about this medication',
        'ai_assistant_description': 'I can help with information about antibiotics, setting up reminders, or answering questions about your medication. How can I assist you today?',
        'back_to_home': 'Back to Home',
        'antibiotic_reminder': 'Antibiotic Reminder',
        'add_new_antibiotic_reminder': 'Add New Antibiotic Reminder',
        'edit_antibiotic_reminder': 'Edit Antibiotic Reminder',
        'medication_name': 'Medication Name',
        'dosage': 'Dosage',
        'frequency': 'Frequency',
        'duration_days': 'Duration (days)',
        'notes_optional': 'Notes (optional)',
        'special_instructions': 'Special Instructions',
        'enter_medication_name': 'Enter medication name (e.g., Amoxicillin)',
        'enter_dosage': 'Enter dosage (e.g., 500mg)',
        'select_frequency': 'Select frequency',
        'enter_duration': 'Enter number of days (e.g., 7)',
        'cancel': 'Cancel',
        'save': 'Save',
        'ask_ai': 'Ask AI',
        'type_your_question_here': 'Type your question here',
        'text_secondary': 'Secondary text color',
        'mediscan': 'MediScan',
        'medical_assistant': 'Medical Assistant',
        'ask_about_medication': 'Ask about your medication',
        'type_message_here': 'Type your message here',
        'assistant_not_available': 'Assistant module not available',
        'welcome_message': 'Hello! I\'m your medical assistant. I can help with information about medications, setting up reminders, or answering questions about your treatment. How can I assist you today?',
        'show_password': 'Show password',
        'sign_up': 'Sign up',
        'back_to_login': 'Back to login',
        'please_fill_all_fields': 'Please fill all fields',
        'passwords_do_not_match': 'Passwords do not match',
        'registration_successful': 'Registration successful'
    },
    'ro': {
        'login': 'Autentificare',
        'username': 'Nume utilizator',
        'password': 'Parolă',
        'register': 'Înregistrare',
        'home_page': 'Acasă',
        'welcome': 'Bine ați venit',
        'settings': 'Setări',
        'notifications': 'Notificări',
        'dark_mode': 'Mod întunecat',
        'sound': 'Sunet',
        'vibration': 'Vibrație',
        'language': 'Limbă',
        'logout': 'Deconectare',
        'add': 'ADAUGĂ',
        'no_reminders_yet': 'Nu există memento-uri pentru antibiotice.\nAtinge + pentru a crea primul reminder.',
        'ready': 'GATA',
        'due_now': 'ACUM',
        'minutes': 'min',
        'taken': 'LUAT',
        'take_now': 'IA ACUM',
        'delete': 'Șterge',
        'edit': 'Editează',
        'ask_ai_assistant': 'Întreabă AI despre această medicament',
        'ai_assistant_description': 'Pot ajuta cu informații despre antibiotice, setarea unor reminder-uri sau răspuns la întrebări despre medicament. Ce pot face pentru tine astăzi?',
        'back_to_home': 'Înapoi la Home',
        'antibiotic_reminder': 'Reminder Antibiotice',
        'add_new_antibiotic_reminder': 'Adaugă un nou reminder pentru antibiotice',
        'edit_antibiotic_reminder': 'Editează reminderul pentru antibiotice',
        'medication_name': 'Nume medicament',
        'dosage': 'Doză',
        'frequency': 'Frecvență',
        'duration_days': 'Durată (zile)',
        'notes_optional': 'Note (opționale)',
        'special_instructions': 'Instrucțiuni speciale',
        'enter_medication_name': 'Introduceți numele medicamentului (e.g., Amoxicillin)',
        'enter_dosage': 'Introduceți doza (e.g., 500mg)',
        'select_frequency': 'Selectați frecvența',
        'enter_duration': 'Introduceți numărul de zile (e.g., 7)',
        'cancel': 'Anulare',
        'save': 'Salvare',
        'ask_ai': 'Întreabă AI',
        'type_your_question_here': 'Introduceți mesajul dvs. aici',
        'text_secondary': 'Culoare text secundară',
        'mediscan': 'MediScan',
        'medical_assistant': 'Asistent Medical',
        'ask_about_medication': 'Întreabă despre medicamentul tău',
        'type_message_here': 'Scrie mesajul tău aici',
        'assistant_not_available': 'Modulul asistent nu este disponibil',
        'welcome_message': 'Bună! Sunt asistentul tău medical. Te pot ajuta cu informații despre medicamente, setarea unor reminder-uri sau răspuns la întrebări despre tratamentul tău. Cu ce te pot ajuta astăzi?',
        'show_password': 'Arată parola',
        'sign_up': 'Înregistrare',
        'back_to_login': 'Înapoi la autentificare'
    },
    'ru': {
        'login': 'Вход',
        'username': 'Имя пользователя',
        'password': 'Пароль',
        'register': 'Регистрация',
        'home_page': 'Главная',
        'welcome': 'Добро пожаловать',
        'settings': 'Настройки',
        'notifications': 'Уведомления',
        'dark_mode': 'Темный режим',
        'sound': 'Звук',
        'vibration': 'Вибрация',
        'language': 'Язык',
        'logout': 'Выход',
        'add': 'ДОБАВИТЬ',
        'no_reminders_yet': 'Нет напоминаний о приеме антибиотиков.\nНажмите + чтобы создать первое напоминание.',
        'ready': 'ГОТОВО',
        'due_now': 'СЕЙЧАС',
        'minutes': 'мин',
        'taken': 'ПРИНЯТО',
        'take_now': 'ПРИНЯТЬ',
        'delete': 'Удалить',
        'edit': 'Изменить',
        'ask_ai_assistant': 'Спросите AI о этом лекарстве',
        'ai_assistant_description': 'Я могу помочь с информацией о антибиотиках, настройкой напоминаний или ответом на вопросы о вашем лекарстве. Как я могу вам помочь сегодня?',
        'back_to_home': 'На главную',
        'antibiotic_reminder': 'Напоминание об антибиотиках',
        'add_new_antibiotic_reminder': 'Добавить новое напоминание об антибиотиках',
        'edit_antibiotic_reminder': 'Редактировать напоминание об антибиотиках',
        'medication_name': 'Название лекарства',
        'dosage': 'Доза',
        'frequency': 'Частота',
        'duration_days': 'Продолжительность (дни)',
        'notes_optional': 'Примечания (необязательно)',
        'special_instructions': 'Специальные инструкции',
        'enter_medication_name': 'Введите название лекарства (например, Амoxicillin)',
        'enter_dosage': 'Введите дозу (например, 500mg)',
        'select_frequency': 'Выберите частоту',
        'enter_duration': 'Введите количество дней (например, 7)',
        'cancel': 'Отмена',
        'save': 'Сохранить',
        'ask_ai': 'Спросить AI',
        'type_your_question_here': 'Введите ваш вопрос здесь',
        'text_secondary': 'Вторичный цвет текста',
        'mediscan': 'MediScan',
        'medical_assistant': 'Медицинский Ассистент',
        'ask_about_medication': 'Спросите о вашем лекарстве',
        'type_message_here': 'Введите ваше сообщение здесь',
        'assistant_not_available': 'Модуль ассистента недоступен',
        'welcome_message': 'Здравствуйте! Я ваш медицинский ассистент. Я могу помочь с информацией о лекарствах, настройкой напоминаний или ответом на вопросы о вашем лечении. Как я могу вам помочь сегодня?',
        'show_password': 'Показать пароль',
        'sign_up': 'Регистрация',
        'back_to_login': 'Вернуться к входу'
    }
}

# Global translation function
def tr(key):
    lang = CURRENT_LANGUAGE['lang']
    return LANG_DICT.get(lang, LANG_DICT['en']).get(key, key)

# Language Manager for handling translations
from kivy.event import EventDispatcher
from kivy.properties import StringProperty

class LanguageManager(EventDispatcher):
    """
    Manages language settings for the application.
    Implemented as a singleton to ensure consistent language across the app.
    """
    _instance = None
    current_language = StringProperty('en')  # Default to English
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(LanguageManager, cls).__new__(cls)
            EventDispatcher.__init__(cls._instance)
            cls._instance.current_language = CURRENT_LANGUAGE['lang']
        return cls._instance
    
    def __init__(self):
        """Initialize language manager"""
        # This will only be called once due to the singleton pattern
        if not hasattr(self, 'is_initialized'):
            self.is_initialized = True
    
    def set_language(self, lang_code):
        """Set the current language"""
        if lang_code in LANGUAGES:
            # Update global language
            CURRENT_LANGUAGE['lang'] = lang_code
            # Update instance language - this triggers bindings
            self.current_language = lang_code
    
    def get_language(self):
        """Get the current language code"""
        return self.current_language
    
    def get_text(self, key):
        """Get translated text for a key"""
        lang = self.current_language
        
        if lang in LANG_DICT and key in LANG_DICT[lang]:
            return LANG_DICT[lang][key]
        
        # Fallback to English
        if 'en' in LANG_DICT and key in LANG_DICT['en']:
            return LANG_DICT['en'][key]
        
        # Return the key itself if not found
        return key

# Base Screen for all other screens
class BaseScreen(Screen):
    def __init__(self, **kwargs):
        # Extract auto_update_theme parameter with default value True
        self.auto_update_theme = kwargs.pop('auto_update_theme', True)
        
        super(BaseScreen, self).__init__(**kwargs)
        self.theme_manager = ThemeManager()
        self.language_manager = LanguageManager()
        
        # Main layout with theme-based background
        self.main_layout = FloatLayout()
        
        # Set background color based on theme
        with self.main_layout.canvas.before:
            self.bg_color = Color(1, 1, 1, 1)  # Default to white
            self.bg_rect = Rectangle(pos=self.main_layout.pos, size=self.main_layout.size)
            self.main_layout.bind(pos=self._update_rect, size=self._update_rect)
        
        # Add a back arrow button to return to home
        self.back_button = Button(
            text='<',
            font_size=dp(24),
            size_hint=(None, None),
            size=(dp(60), dp(60)),  # Updated to match reminder section
            pos_hint={'x': 0, 'top': 1},
            background_normal='',
            background_color=(0.92, 0.92, 0.92, 1),  # Light grey color to match nav bar
            color=(0.2, 0.2, 0.2, 1)  # Dark text for better contrast on light background
        )
        self.back_button.bind(on_press=self.go_back)
        self.main_layout.add_widget(self.back_button)
        
        self.add_widget(self.main_layout)
        
        # Update theme if auto_update_theme is True
        if self.auto_update_theme:
            self.update_theme()
        
        # Bind to theme changes
        self.theme_manager.bind(is_dark_mode=self.update_theme)
    
    def _update_rect(self, instance, value):
        self.bg_rect.pos = instance.pos
        self.bg_rect.size = instance.size
    
    def update_theme(self, *args):
        """Update the theme colors"""
        colors = self.theme_manager.get_colors()
        
        # Update background color
        if hasattr(self, 'bg_color'):
            self.bg_color.rgba = colors['background']
        
        # Update back button colors - always keep light grey regardless of theme
        if hasattr(self, 'back_button'):
            if self.theme_manager.is_dark_mode:
                self.back_button.background_color = (0.2, 0.2, 0.22, 1)  # Darker grey for dark mode
                self.back_button.color = (0.9, 0.9, 0.9, 1)  # Light text for dark mode
            else:
                self.back_button.background_color = (0.92, 0.92, 0.92, 1)  # Light grey for light mode
                self.back_button.color = (0.2, 0.2, 0.2, 1)  # Dark text for light mode
                
        # Update all widgets with theme colors
        for child in self.walk(restrict=True):
            # Update labels
            if isinstance(child, Label):
                if getattr(child, 'bold', False) and getattr(child, 'font_size', 0) > dp(18):
                    # This is likely a title - use primary color
                    child.color = colors.get('primary', colors['text'])
                else:
                    # Regular text
                    child.color = colors['text']
            
            # Update standard buttons
            elif isinstance(child, Button) and child != self.back_button:
                # Only update standard buttons, not custom ones
                if not any(isinstance(child, cls) for cls in [RoundedButton, IconButton]):
                    child.background_color = colors['button_bg']
                    child.color = colors['button_text']
                    
            # Update text inputs
            elif isinstance(child, TextInput):
                child.background_color = colors['input_bg']
                child.foreground_color = colors['text']
                child.cursor_color = colors['primary']
    
    def go_back(self, *args):
        """Navigate back to the home screen"""
        self.manager.current = 'home'

class IconWidget(Widget):
    def __init__(self, icon_type='', **kwargs):
        super(IconWidget, self).__init__(**kwargs)
        self.icon_type = icon_type
        self.size_hint = (None, None)
        self.size = (dp(30), dp(30))
        self.bind(pos=self.update_canvas)
        self.bind(size=self.update_canvas)
    
    def update_canvas(self, *args):
        self.canvas.clear()
        with self.canvas:
            Color(0.2, 0.2, 0.2, 1)  # Dark gray color for icons
            
            if self.icon_type == 'home':
                # House icon
                points = [
                    self.center_x, self.top,  # Top of roof
                    self.x + dp(4), self.center_y + dp(4),  # Left roof
                    self.x + dp(4), self.y + dp(4),  # Left wall
                    self.right - dp(4), self.y + dp(4),  # Bottom wall
                    self.right - dp(4), self.center_y + dp(4),  # Right wall
                    self.center_x, self.top  # Back to top
                ]
                Line(points=points, width=dp(1.5))
                # Door
                door_points = [
                    self.center_x - dp(4), self.y + dp(4),  # Door left
                    self.center_x - dp(4), self.center_y - dp(4),  # Door top left
                    self.center_x + dp(4), self.center_y - dp(4),  # Door top right
                    self.center_x + dp(4), self.y + dp(4)  # Door right
                ]
                Line(points=door_points, width=dp(1.5))
                
            elif self.icon_type == 'reminder':
                # Clock icon
                Line(circle=(self.center_x, self.center_y, min(self.width, self.height)/2 - dp(4)), width=dp(1.5))
                # Clock hands
                Line(points=[self.center_x, self.center_y, self.center_x, self.top - dp(8)], width=dp(1.5))
                Line(points=[self.center_x, self.center_y, self.right - dp(8), self.center_y], width=dp(1.5))
                
            elif self.icon_type == 'camera':
                # Camera body
                Line(rectangle=(self.x + dp(4), self.y + dp(4), self.width - dp(8), self.height - dp(8)), width=dp(1.5))
                # Lens
                Line(circle=(self.center_x, self.center_y, min(self.width, self.height)/4), width=dp(1.5))
                # Flash
                Line(rectangle=(self.right - dp(8), self.top - dp(12), dp(4), dp(4)), width=dp(1.5))
                
            elif self.icon_type == 'voice':
                # YouTube-style microphone icon
                # Microphone stand
                Line(points=[
                    self.center_x, self.y + dp(4),
                    self.center_x, self.top - dp(4)
                ], width=dp(2))
                # Microphone head (circle)
                Line(circle=(self.center_x, self.top - dp(4), dp(6)), width=dp(2))
                # Microphone base (small rectangle)
                Line(rectangle=(self.center_x - dp(4), self.y + dp(4), dp(8), dp(2)), width=dp(2))
                
            elif self.icon_type == 'settings':
                # Gear icon
                Line(circle=(self.center_x, self.center_y, min(self.width, self.height)/3), width=dp(1.5))
                # Gear teeth
                for i in range(8):
                    angle = i * math.pi / 4
                    radius = min(self.width, self.height)/2 - dp(4)
                    x1 = self.center_x + radius * 0.7 * math.cos(angle)
                    y1 = self.center_y + radius * 0.7 * math.sin(angle)
                    x2 = self.center_x + radius * math.cos(angle)
                    y2 = self.center_y + radius * math.sin(angle)
                    Line(points=[x1, y1, x2, y2], width=dp(1.5))

class IconButton(ButtonBehavior, BoxLayout):
    icon_type = StringProperty('')
    text = StringProperty('')
    
    def __init__(self, **kwargs):
        super(IconButton, self).__init__(**kwargs)
        self.theme_manager = ThemeManager()
        self.orientation = 'vertical'
        self.size_hint = (1, 1)
        self.spacing = dp(5)
        self.padding = dp(5)
        
        # Create an image widget for the icon
        self.icon_image = Image(
            source='',  # Will be set by _update_icon
            size_hint=(None, None),
            size=(dp(35), dp(35)),  # Increased from 30 to 35
            allow_stretch=True,
            keep_ratio=True,
            color=(0.2, 0.2, 0.2, 1)  # Initial color, will be updated by theme
        )
        
        # Center the icon
        icon_layout = AnchorLayout(
            anchor_x='center',
            anchor_y='center',
            size_hint=(1, 0.7)
        )
        
        icon_layout.add_widget(self.icon_image)
        self.add_widget(icon_layout)
        
        # Create label
        label_layout = AnchorLayout(
            anchor_x='center',
            anchor_y='center',
            size_hint=(1, 0.3)
        )
        self.label = Label(
            text=self.text,
            font_size=dp(11),
            color=(0.2, 0.2, 0.2, 1),  # Will be updated by theme
            size_hint=(1, None),
            height=dp(20),
            bold=True,
            halign='center'
        )
        label_layout.add_widget(self.label)
        self.add_widget(label_layout)
        
        # Bind properties
        self.bind(icon_type=self._update_icon)
        self.bind(text=self._update_text)
        
        # Initialize icon if icon_type was provided in kwargs
        if 'icon_type' in kwargs:
            self._update_icon(self, kwargs['icon_type'])
        
        # Update theme initially and bind to theme changes
        self.update_theme()
        self.theme_manager.bind(is_dark_mode=self.update_theme)
    
    def _update_icon(self, instance, value):
        # Map icon types to icon image files with absolute paths
        import os
        app_dir = os.path.dirname(os.path.abspath(__file__))
        icon_mapping = {
            'home': os.path.join(app_dir, 'icons', 'home-icon-silhouette.png'),
            'reminder': os.path.join(app_dir, 'icons', 'bell.png'),
            'mediscan': os.path.join(app_dir, 'icons', 'x-ray.png'),
            'voice': os.path.join(app_dir, 'icons', 'microphone.png'),
            'settings': os.path.join(app_dir, 'icons', 'setting.png')
        }
        
        # Get the absolute path to the icon
        icon_path = icon_mapping.get(value, '')
        if icon_path and os.path.exists(icon_path):
            # Set the source and ensure it's visible
            self.icon_image.source = icon_path
            # Set larger size specifically for MediScan icon
            if value == 'mediscan':
                self.icon_image.size = (dp(45), dp(45))
            else:
                self.icon_image.size = (dp(35), dp(35))
            self.icon_image.opacity = 1
        else:
            # Hide the icon if no path is found or file doesn't exist
            self.icon_image.opacity = 0
    
    def _update_text(self, instance, value):
        self.label.text = value
        self.update_theme()  # Update colors based on current theme
    
    def update_theme(self, *args):
        """Update colors based on current theme"""
        is_dark = self.theme_manager.is_dark_mode
        
        # Update icon and text colors based on theme
        if is_dark:
            self.icon_image.color = (0.9, 0.9, 0.9, 1)  # Light color for dark mode
            self.label.color = (0.9, 0.9, 0.9, 1)
        else:
            self.icon_image.color = (0.2, 0.2, 0.2, 1)  # Dark color for light mode
            self.label.color = (0.2, 0.2, 0.2, 1)
    
    def on_press(self):
        # Change to a pressed state color based on theme
        is_dark = self.theme_manager.is_dark_mode
        if is_dark:
            self.icon_image.color = (1, 1, 1, 1)  # White for dark mode
            self.label.color = (1, 1, 1, 1)
        else:
            self.icon_image.color = (0, 0, 0, 1)  # Black for light mode
            self.label.color = (0, 0, 0, 1)
        
        # Get the HomeScreen instance to handle navigation
        app = App.get_running_app()
        if hasattr(app.root.current_screen, 'navigate_to'):
            app.root.current_screen.navigate_to(self.icon_type)
    
    def on_release(self):
        # Restore colors based on current theme
        self.update_theme()

# Reminder Screen with antibiotics reminder functionality
from kivy.uix.scrollview import ScrollView
from kivy.uix.gridlayout import GridLayout
from kivy.uix.textinput import TextInput
from kivy.uix.spinner import Spinner
from kivy.metrics import dp
from kivy.graphics import Color, RoundedRectangle
from kivy.properties import ObjectProperty, StringProperty, BooleanProperty
from kivy.clock import Clock
from datetime import datetime, timedelta
import os

# Import the medication reminder module
try:
    from medication_reminder import MedicationReminder
except ImportError:
    pass  # Will handle this in the class

class RoundedButton(Button):
    def __init__(self, **kwargs):
        # Extract our custom properties before passing to the parent class
        self.bg_color = kwargs.pop('bg_color', kwargs.pop('color', (0.2, 0.6, 0.9, 1)))  # Support both bg_color and color
        text_color = kwargs.pop('text_color', (1, 1, 1, 1))  # Default white text
        
        # Now call the parent with the cleaned kwargs
        super(RoundedButton, self).__init__(**kwargs)
        
        # Set up button properties
        self.background_normal = ''
        self.background_color = (0, 0, 0, 0)  # Transparent
        self.background_down = ''
        self.color = text_color  # Text color
        
        # Store the pressed state background color
        self.background_color_down = (0.7, 0.7, 0.7, 1)  # Light gray when pressed
        
        # Bind canvas update to size/position changes
        self.bind(pos=self._update_canvas, size=self._update_canvas)

    def _update_canvas(self, *args):
        self.canvas.before.clear()
        with self.canvas.before:
            Color(*self.bg_color)
            RoundedRectangle(pos=self.pos, size=self.size, radius=[dp(10)])

    def on_press(self):
        self.canvas.before.clear()
        with self.canvas.before:
            Color(*self.background_color_down)
            RoundedRectangle(pos=self.pos, size=self.size, radius=[dp(10)])

    def on_release(self):
        self._update_canvas()

class ReminderCard(BoxLayout):
    reminder_id = StringProperty('')

    def __init__(self, reminder_data, **kwargs):
        super(ReminderCard, self).__init__(**kwargs)
        self.orientation = 'vertical'
        self.size_hint_y = None
        self.height = dp(300)  # Increased height to accommodate larger buttons
        self.padding = [dp(15), dp(15)]
        self.spacing = dp(10)
        self.reminder_data = reminder_data
        self.reminder_id = reminder_data.get('id', '')
        self.theme_manager = ThemeManager()
        
        # Load saved data from JSON file
        try:
            if os.path.exists('reminders.json'):
                with open('reminders.json', 'r') as f:
                    saved_reminders = json.load(f)
                    for saved_reminder in saved_reminders:
                        if saved_reminder.get('id') == self.reminder_id:
                            # Update reminder_data with saved values
                            self.reminder_data.update(saved_reminder)
                            break
        except Exception as e:
            print(f"Error loading saved reminder data: {e}")
        
        # Store next dose time if available
        self.next_dose_time = None
        if self.reminder_data.get('next_time'):
            try:
                self.next_dose_time = datetime.fromisoformat(self.reminder_data['next_time'])
                # If the next dose time is in the past, reset it
                if self.next_dose_time < datetime.now():
                    self.next_dose_time = None
            except (ValueError, TypeError):
                self.next_dose_time = None
        
        # Set up doses tracking
        self.frequency = self.reminder_data.get('frequency', 'Once daily')
        self.duration = int(self.reminder_data.get('duration', 1))
        self.doses_taken = int(self.reminder_data.get('doses_taken', 0))
        self.total_doses = self.calculate_total_doses()
        
        # Set up background with rounded corners
        with self.canvas.before:
            self.bg_color = Color(0.95, 0.95, 1, 1)  # Very light blue background
            self.bg_rect = RoundedRectangle(pos=self.pos, size=self.size, radius=[dp(15)])
        self.bind(pos=self._update_rect, size=self._update_rect)
        
        # Create a main horizontal layout
        main_layout = BoxLayout(orientation='horizontal', spacing=dp(15))
        
        # Left side with details
        left_side = BoxLayout(
            orientation='vertical',
            size_hint=(0.6, 1),
            spacing=dp(10)
        )
        
        # Add medication name as title
        title_layout = BoxLayout(size_hint=(1, None), height=dp(40))
        
        self.title = Label(
            text=reminder_data.get('medication_name', 'Medication'),
            font_size=dp(24),  # Larger font size
            bold=True,
            color=(0.2, 0.4, 0.8, 1),  # Blue text
            size_hint=(1, 1),
            halign='left',
            valign='middle'
        )
        self.title.bind(size=self.title.setter('text_size'))
        title_layout.add_widget(self.title)
        left_side.add_widget(title_layout)
        
        # Add description info
        description_layout = BoxLayout(
            orientation='vertical',
            size_hint=(1, None),
            height=dp(120),  # Increased height for description
            spacing=dp(5)
        )
        
        # Frequency and duration info
        self.description = Label(
            text=self._get_description_text(),
            font_size=dp(16),
            color=(0.2, 0.2, 0.2, 1),
            size_hint=(1, 1),
            halign='left',
            valign='top'
        )
        self.description.bind(size=self.description.setter('text_size'))
        description_layout.add_widget(self.description)
        
        # Add notes if available
        if reminder_data.get('notes'):
            self.notes = Label(
                text=f"Notes: {reminder_data.get('notes')}",
                font_size=dp(14),
                color=(0.4, 0.4, 0.4, 1),
                size_hint=(1, None),
                height=dp(40),
                halign='left',
                valign='top'
            )
            self.notes.bind(size=self.notes.setter('text_size'))
            description_layout.add_widget(self.notes)
        
        left_side.add_widget(description_layout)
        
        # Add edit button at the bottom of left side
        edit_btn = RoundedButton(
            text=tr("edit"),
            size_hint=(1, None),
            height=dp(50),  # Increased height for better touchability
            bg_color=(0.2, 0.6, 0.9, 1)  # Blue
        )
        edit_btn.bind(on_release=lambda x: self.edit_reminder())
        left_side.add_widget(edit_btn)
        
        # Right side with cooldown circle and buttons
        right_side = BoxLayout(
            orientation='vertical',
            size_hint=(0.4, 1),
            spacing=dp(10)
        )
        
        # Cooldown circle container
        self.cooldown_container = RelativeLayout(
            size_hint=(None, None),
            size=(dp(120), dp(120)),  # Increased circle size
            pos_hint={'center_x': 0.5, 'top': 1}
        )
        
        # Create cooldown circle with theme-based colors
        with self.cooldown_container.canvas:
            # Background circle (light gray)
            self.circle_bg_color = Color(0.85, 0.85, 0.85, 1)
            self.circle_bg = Ellipse(pos=(0, 0), size=(dp(120), dp(120)))
            
            # Progress circle (green/blue) that shows remaining time
            self.circle_progress_color = Color(0.2, 0.7, 0.3, 1)  # Green for ready
            self.circle_progress = Ellipse(
                pos=(0, 0), 
                size=(dp(120), dp(120)),
                angle_start=0,
                angle_end=360  # Full circle initially
            )
        
        # Cooldown time label inside circle
        self.cooldown_label = Label(
            text=tr('ready'),
            font_size=dp(24),  # Larger font
            bold=True,
            color=(1, 1, 1, 1),  # White text on colored background
            size_hint=(None, None),
            size=(dp(120), dp(120)),
            halign='center',
            valign='middle'
        )
        self.cooldown_label.bind(size=self.cooldown_label.setter('text_size'))
        
        self.cooldown_container.add_widget(self.cooldown_label)
        right_side.add_widget(self.cooldown_container)
        
        # Add Take Now button using RoundedButton
        self.take_button = RoundedButton(
            text=tr('take_now'),
            size_hint=(1, None),
            height=dp(60),  # Increased height for better touchability
            bg_color=(0.2, 0.7, 0.3, 0.8)  # Green, partially transparent
        )
        self.take_button.bind(on_release=self.take_medication)
        right_side.add_widget(self.take_button)
        
        # Add delete button
        delete_btn = RoundedButton(
            text=tr("delete"),
            size_hint=(1, None),
            height=dp(50),  # Increased height for better touchability
            bg_color=(0.9, 0.3, 0.3, 1)  # Red
        )
        delete_btn.bind(on_release=lambda x: self.delete_reminder())
        right_side.add_widget(delete_btn)
        
        # Add both sides to main layout
        main_layout.add_widget(left_side)
        main_layout.add_widget(right_side)
        self.add_widget(main_layout)
        
        # Check cooldown status initially and update UI
        self.check_cooldown_status()
        
        # Bind to position/size updates to keep cooldown circle positioned correctly
        self.bind(pos=self._update_cooldown_pos, size=self._update_cooldown_pos)
        
        # Start periodic cooldown check (every minute)
        Clock.schedule_interval(self.check_cooldown_status, 60)

    def _get_description_text(self):
        """Generate description text based on reminder data"""
        frequency = self.reminder_data.get('frequency', 'Once daily')
        duration = self.reminder_data.get('duration', 1)
        dosage = self.reminder_data.get('dosage', 'N/A')
        
        return f"Frequency: {frequency}\nDuration: {duration} day{'s' if duration > 1 else ''}\nDosage: {dosage}\nDoses taken: {self.doses_taken}/{self.total_doses}"

    def calculate_total_doses(self):
        """Calculate total number of doses based on frequency and duration"""
        frequency = self.reminder_data.get('frequency', 'Once daily')
        duration = int(self.reminder_data.get('duration', 1))
        
        # Calculate doses per day based on frequency
        if frequency == 'Once daily':
            doses_per_day = 1
        elif frequency == 'Twice daily':
            doses_per_day = 2
        elif frequency == 'Three times daily':
            doses_per_day = 3
        elif frequency == 'Four times daily':
            doses_per_day = 4
        elif frequency.startswith('Every '):
            # Extract hours from "Every X hours"
            try:
                hours = int(frequency.split()[1])
                # Calculate doses per day based on active hours (16 hours)
                doses_per_day = 16 // hours
            except (ValueError, IndexError):
                doses_per_day = 1
        else:
            doses_per_day = 1
        
        return doses_per_day * duration

    def get_cooldown_minutes(self, frequency):
        """Calculate cooldown time in minutes based on frequency"""
        if frequency == 'Once daily':
            return 24 * 60  # 24 hours
        elif frequency == 'Twice daily':
            return 12 * 60  # 12 hours
        elif frequency == 'Three times daily':
            return 6 * 60   # 8 hours
        elif frequency == 'Four times daily':
            return 4 * 60   # 6 hours
        elif frequency.startswith('Every '):
            try:
                hours = int(frequency.split()[1])
                return hours * 60
            except (ValueError, IndexError):
                return 24 * 60
        else:
            return 24 * 60

    def check_cooldown_status(self, dt=None):
        now = datetime.now()
        # Check if all doses have been taken
        if self.doses_taken >= self.total_doses:
            self.take_button.disabled = True
            self.take_button.opacity = 0.5
            self.take_button.text = 'Completed'
            self.cooldown_label.text = 'Completed'
            self.cooldown_label.color = (1, 1, 1, 1)  # White text
            self.circle_progress_color.rgba = (0.4, 0.4, 0.4, 1)  # Gray circle
            self.circle_progress.angle_end = 360  # Full circle
            return False
        if not self.next_dose_time:
            # No next dose time set, enable take button
            self.take_button.disabled = False
            self.take_button.opacity = 1
            self.take_button.text = 'Take Now'
            self.cooldown_label.text = 'Ready'
            self.cooldown_label.color = (1, 1, 1, 1)  # White text
            self.circle_progress_color.rgba = (0.2, 0.8, 0.2, 1)  # Green
            self.circle_progress.angle_end = 360  # Full circle
            return False
        if now >= self.next_dose_time:
            # Cooldown completed, enable take button
            self.take_button.disabled = False
            self.take_button.opacity = 1
            self.take_button.text = 'Take Now'
            self.cooldown_label.text = 'Due Now'
            self.cooldown_label.color = (1, 1, 1, 1)  # White text
            self.circle_progress_color.rgba = (0.2, 0.8, 0.2, 1)  # Green
            self.circle_progress.angle_end = 360  # Full circle
            return False
        # Still in cooldown, update time left
        time_diff = self.next_dose_time - now
        total_seconds = self.get_cooldown_minutes(self.frequency) * 60
        # Progress: fill up as time passes
        progress_percent = max(1.0 - (time_diff.total_seconds() / total_seconds), 0.0)
        angle_end = 360 * progress_percent
        self.circle_progress.angle_end = angle_end
        # Update cooldown text - showing both hours and minutes
        if time_diff.days > 0:
            cooldown_text = f"{time_diff.days}\ndays"
        elif time_diff.seconds // 3600 > 0:
            hours = time_diff.seconds // 3600
            minutes = (time_diff.seconds % 3600) // 60
            cooldown_text = f"{hours}h\n{minutes}m"
        else:
            cooldown_text = f"{time_diff.seconds // 60}\nmin"
        self.cooldown_label.text = cooldown_text
        self.cooldown_label.color = (1, 1, 1, 1)  # White text
        self.circle_progress_color.rgba = (0.2, 0.4, 0.8, 1)  # Blue during cooldown
        self.take_button.disabled = True
        self.take_button.opacity = 0.5
        self.take_button.text = 'Taken'
        return True

    def take_medication(self, instance):
        """Record that medication was taken and update next dose time"""
        self.doses_taken += 1
        
        # Calculate next dose time based on frequency
        cooldown_minutes = self.get_cooldown_minutes(self.frequency)
        self.next_dose_time = datetime.now() + timedelta(minutes=cooldown_minutes)
        
        # Update UI
        self.check_cooldown_status()
        
        # Update reminder data
        self.reminder_data['doses_taken'] = self.doses_taken
        self.reminder_data['next_time'] = self.next_dose_time.isoformat()
        
        # Save to JSON file
        try:
            # Load existing reminders
            reminders = []
            if os.path.exists('reminders.json'):
                with open('reminders.json', 'r') as f:
                    reminders = json.load(f)
            
            # Update the specific reminder
            for reminder in reminders:
                if reminder.get('id') == self.reminder_id:
                    reminder['doses_taken'] = self.doses_taken
                    reminder['next_time'] = self.next_dose_time.isoformat()
                    break
            
            # Save back to file
            with open('reminders.json', 'w') as f:
                json.dump(reminders, f)
                
            print(f"Saved reminder data: doses_taken={self.doses_taken}, next_time={self.next_dose_time}")
        except Exception as e:
            print(f"Error saving reminder data: {e}")

    def _update_rect(self, *args):
        self.bg_rect.pos = self.pos
        self.bg_rect.size = self.size
    
    def _update_cooldown_pos(self, *args):
        """Update cooldown wheel position"""
        if hasattr(self, 'cooldown_container') and hasattr(self, 'circle_bg'):
            # Ensure the circles fill the entire container
            self.circle_bg.pos = (0, 0)
            self.circle_bg.size = self.cooldown_container.size
            
            self.circle_progress.pos = (0, 0)
            self.circle_progress.size = self.cooldown_container.size

    def update_theme(self):
        """Update theme colors"""
        colors = self.theme_manager.get_colors()
        is_dark = self.theme_manager.is_dark_mode
        
        # Update background
        if is_dark:
            self.bg_color.rgba = (0.15, 0.15, 0.18, 1)  # Darker background for dark mode
        else:
            self.bg_color.rgba = (0.95, 0.95, 1, 1)  # Light blue background for light mode
        
        # Update text colors
        self.title.color = colors['primary']
        self.description.color = colors['text']
        if hasattr(self, 'notes'):
            self.notes.color = colors['text_secondary']
        
        # Update take button
        if is_dark:
            self.take_button.bg_color = (0.15, 0.4, 0.2, 0.8)  # Darker green
        else:
            self.take_button.bg_color = (0.2, 0.7, 0.3, 0.8)  # Standard green
        
        # Update cooldown colors based on status
        if self.cooldown_label.text == tr('ready'):
            self.cooldown_label.color = colors['text']
        else:
            self.cooldown_label.color = (1, 1, 1, 1)  # White text on colored background

    def edit_reminder(self):
        """Signal to parent screen to edit this reminder"""
        screen = App.get_running_app().root.current_screen
        if hasattr(screen, 'show_edit_reminder'):
            screen.show_edit_reminder(self.reminder_id)
    
    def delete_reminder(self):
        """Signal to parent screen to delete this reminder"""
        screen = App.get_running_app().root.current_screen
        if hasattr(screen, 'delete_reminder'):
            screen.delete_reminder(self.reminder_id)

class ReminderScreen(BaseScreen):
    reminder_manager = ObjectProperty(None)
    is_adding_reminder = BooleanProperty(False)
    editing_reminder_id = StringProperty('')
    form_visible = BooleanProperty(False)  # Track form visibility
    
    def __init__(self, **kwargs):
        # Pass auto_update_theme=False to prevent premature call to update_theme
        super(ReminderScreen, self).__init__(auto_update_theme=False, **kwargs)
        
        # Make the back button larger and positioned in the corner
        self.back_button.size = (dp(60), dp(60))
        self.back_button.font_size = dp(24)
        self.back_button.pos_hint = {'x': 0, 'top': 1}
        self.back_button.background_color = (0.8, 0.8, 0.8, 1)  # Grey color
        
        # Initialize the medication reminder manager
        try:
            self.reminder_manager = MedicationReminder()
        except NameError:
            print("MedicationReminder class not found, using a mock implementation")
            from medication_reminder_mock import MockMedicationReminder
            self.reminder_manager = MockMedicationReminder()
        
        self.language_manager = LanguageManager()
        
        # Add title with more modern styling - dark grey and centered
        title_bar = BoxLayout(
            orientation='horizontal',
            size_hint=(1, None),
            height=dp(80),  # Increased height for more space
            pos_hint={'top': 1},
            padding=[dp(20), dp(15), dp(20), 0]  # Added horizontal padding
        )
        
        self.title_label = Label(
            text=tr('antibiotic_reminder'),
            font_size=dp(28),  # Increased from 24 to 28
            bold=True,
            color=(0.2, 0.4, 0.8, 1),  # Blue text color
            size_hint=(1, 1),
            halign='center',  # Center-aligned text
            valign='middle',
            pos_hint={'center_x': 0.5, 'center_y': 0.5}
        )
        # Ensure the text alignment applies
        self.title_label.bind(size=self.title_label.setter('text_size'))
        
        title_bar.add_widget(self.title_label)
        self.main_layout.add_widget(title_bar)
        
        # Content area for reminders with scroll view
        self.scroll_view = ScrollView(
            size_hint=(1, None),
            height=dp(480),  # Reduced height to leave more space for button
            pos_hint={'center_x': 0.5, 'top': 0.9}
        )
        
        # This will hold our reminder cards
        self.reminders_layout = GridLayout(
            cols=1,
            spacing=dp(15),
            padding=[dp(10), dp(10), dp(10), dp(120)],  # Added bottom padding to prevent overlap with button
            size_hint_y=None,  # Required for scrolling
        )
        self.reminders_layout.bind(minimum_height=self.reminders_layout.setter('height'))
        
        self.scroll_view.add_widget(self.reminders_layout)
        self.main_layout.add_widget(self.scroll_view)
        
        # Create a circular Add button at the bottom center of the page
        add_button_container = BoxLayout(
            orientation='vertical',
            size_hint=(None, None),
            width=dp(70),
            height=dp(70),
            pos_hint={'center_x': 0.5, 'y': 0.05}  # Moved down from 0.08 to 0.05
        )
        
        # Create a circular button with proper touch detection
        circle_btn = RoundButton(
            text='+',
            font_size=dp(42),
            bold=True,
            size_hint=(None, None),
            size=(dp(60), dp(60)),
            pos_hint={'center_x': 0.5, 'center_y': 0.5},
            bg_color=(0.2, 0.7, 0.3, 1),  # Green background
            fg_color=(1, 1, 1, 1)  # White text
        )
        circle_btn.bind(on_release=self.show_add_reminder)
        
        # Add the button directly to the container
        add_button_container.add_widget(circle_btn)
        
        # Store the reference we'll need for callback and updates
        self.circle_plus_btn = circle_btn
        
        # Add to main layout
        self.main_layout.add_widget(add_button_container)
        
        # No reminders message
        self.no_reminders_label = Label(
            text=tr('no_reminders_yet'),
            font_size=dp(18),
            color=(0.6, 0.6, 0.6, 1),
            size_hint=(1, None),
            height=dp(80),
            pos_hint={'center_x': 0.5, 'center_y': 0.5}
        )
        self.main_layout.add_widget(self.no_reminders_label)
        
        # Container for add/edit reminder form (hidden initially)
        self.form_container = FloatLayout(
            size_hint=(1, 1),  # Make it fullscreen
            pos_hint={'center_x': 0.5, 'center_y': 0.5},  # Center it
            opacity=0
        )
        
        # Form background
        with self.form_container.canvas.before:
            # Use color variable so we can update it in the update_theme method
            self.form_bg_color = Color(0.97, 0.97, 0.97, 1)
            self.form_bg = RoundedRectangle(pos=(0, 0), size=(0, 0), radius=[dp(20)])
        self.form_container.bind(pos=self._update_form_bg, size=self._update_form_bg)
        
        # Form contents
        form_grid = GridLayout(
            cols=1,
            spacing=dp(10),  # Reduced spacing from 15 to 10
            padding=[dp(25), dp(15), dp(25), dp(15)],  # Left, top, right, bottom padding
            size_hint=(0.95, 0.95),
            pos_hint={'center_x': 0.5, 'center_y': 0.5}
        )
        
        self.form_title = Label(
            text=tr("add_new_antibiotic_reminder"),
            font_size=dp(20),
            bold=True,
            color=(0.2, 0.4, 0.8, 1),
            size_hint=(1, None),
            height=dp(35)  # Reduced height
        )
        form_grid.add_widget(self.form_title)
        
        # Medication name
        name_layout = BoxLayout(orientation='vertical', size_hint=(1, None), height=dp(70))
        self.name_label = Label(
            text=tr("medication_name"),
            font_size=dp(16),
            color=(0.3, 0.3, 0.3, 1),
            halign='left',
            size_hint=(1, None),
            height=dp(25)
        )
        self.name_label.bind(size=self.name_label.setter('text_size'))
        
        self.name_input = TextInput(
            hint_text=tr("enter_medication_name"),
            multiline=False,
            size_hint=(1, None),
            height=dp(45),
            padding=[dp(10), dp(10)],
            font_size=dp(16)
        )
        name_layout.add_widget(self.name_label)
        name_layout.add_widget(self.name_input)
        form_grid.add_widget(name_layout)
        
        # Dosage
        dosage_layout = BoxLayout(orientation='vertical', size_hint=(1, None), height=dp(70))
        self.dosage_label = Label(
            text=tr("dosage"),
            font_size=dp(16),
            color=(0.3, 0.3, 0.3, 1),
            halign='left',
            size_hint=(1, None),
            height=dp(25)
        )
        self.dosage_label.bind(size=self.dosage_label.setter('text_size'))
        
        self.dosage_input = TextInput(
            hint_text=tr("enter_dosage"),
            multiline=False,
            size_hint=(1, None),
            height=dp(45),
            padding=[dp(10), dp(10)],
            font_size=dp(16)
        )
        dosage_layout.add_widget(self.dosage_label)
        dosage_layout.add_widget(self.dosage_input)
        form_grid.add_widget(dosage_layout)
        
        # Frequency
        frequency_layout = BoxLayout(orientation='vertical', size_hint=(1, None), height=dp(70))
        self.frequency_label = Label(
            text=tr("frequency"),
            font_size=dp(16),
            color=(0.3, 0.3, 0.3, 1),
            halign='left',
            size_hint=(1, None),
            height=dp(25)
        )
        self.frequency_label.bind(size=self.frequency_label.setter('text_size'))
        
        # Create a button with the selected frequency
        self.frequency_button = RoundedButton(
            text=tr("select_frequency"),
            font_size=dp(16),
            bg_color=(0xfd/255, 0xde/255, 0x86/255, 1),  # #fdde86 (yellow)
            color=(0, 0, 0, 1),  # Pure black text on yellow background
            size_hint=(1, None),
            height=dp(45)
        )
        
        # Directly bind to toggle_frequency_options
        self.frequency_button.bind(on_release=self.toggle_frequency_options)
        
        frequency_layout.add_widget(self.frequency_label)
        frequency_layout.add_widget(self.frequency_button)
        form_grid.add_widget(frequency_layout)
        
        # Connect spinner directly to button for backward compatibility with existing code
        
        # Duration
        duration_layout = BoxLayout(orientation='vertical', size_hint=(1, None), height=dp(70))
        self.duration_label = Label(
            text=tr("duration_days"),
            font_size=dp(16),
            color=(0.3, 0.3, 0.3, 1),
            halign='left',
            size_hint=(1, None),
            height=dp(25)
        )
        self.duration_label.bind(size=self.duration_label.setter('text_size'))
        
        self.duration_input = TextInput(
            hint_text=tr("enter_duration"),
            multiline=False,
            input_filter='int',
            size_hint=(1, None),
            height=dp(45),
            padding=[dp(10), dp(10)],
            font_size=dp(16)
        )
        duration_layout.add_widget(self.duration_label)
        duration_layout.add_widget(self.duration_input)
        form_grid.add_widget(duration_layout)
        
        # Notes
        notes_layout = BoxLayout(orientation='vertical', size_hint=(1, None), height=dp(100))
        self.notes_label = Label(
            text=tr("notes_optional"),
            font_size=dp(16),
            color=(0.3, 0.3, 0.3, 1),
            halign='left',
            size_hint=(1, None),
            height=dp(25)
        )
        self.notes_label.bind(size=self.notes_label.setter('text_size'))
        
        self.notes_input = TextInput(
            hint_text=tr("special_instructions"),
            multiline=True,
            size_hint=(1, None),
            height=dp(75),
            padding=[dp(10), dp(10)],
            font_size=dp(16)
        )
        notes_layout.add_widget(self.notes_label)
        notes_layout.add_widget(self.notes_input)
        form_grid.add_widget(notes_layout)
        
        # Buttons
        button_layout = BoxLayout(size_hint=(1, None), height=dp(50), spacing=dp(20))
        
        self.cancel_btn = RoundedButton(
            text=tr("cancel"),
            size_hint=(0.5, 1),
            bg_color=(0.9, 0.3, 0.3, 1),  # Red color
            color=(1, 1, 1, 1)  # White text
        )
        self.cancel_btn.bind(on_release=self.hide_form)
        
        self.save_btn = RoundedButton(
            text=tr("save"),
            size_hint=(0.5, 1),
            bg_color=(0.2, 0.7, 0.3, 1)  # Green
        )
        self.save_btn.bind(on_release=self.save_reminder)
        
        button_layout.add_widget(self.cancel_btn)
        button_layout.add_widget(self.save_btn)
        form_grid.add_widget(button_layout)
        
        # Add a button to ask AI for help
        ai_button_layout = BoxLayout(size_hint=(1, None), height=dp(60), padding=[0, dp(10)])
        
        self.ai_help_btn = RoundedButton(
            text=tr('ask_ai_assistant'),
            size_hint=(1, 1),
            bg_color=(0.5, 0.3, 0.9, 1)  # Purple
        )
        self.ai_help_btn.bind(on_release=self.ask_ai_about_medication)
        # Initially disable the button since the form is not visible yet
        self.ai_help_btn.disabled = True
        
        ai_button_layout.add_widget(self.ai_help_btn)
        form_grid.add_widget(ai_button_layout)
        
        self.form_container.add_widget(form_grid)
        self.main_layout.add_widget(self.form_container)
        
        # Create a dropdown for frequency selection
        self.frequency_dropdown = DropDown(
            auto_width=False,
            width=dp(200),
            max_height=dp(250)  # Limit the height to make it more compact
        )
        
        # Frequency options
        frequencies = [
            'Once daily', 
            'Twice daily', 
            'Three times daily', 
            'Four times daily',
            'Every 1 hour',
            'Every 2 hours',
            'Every 3 hours',
            'Every 4 hours',
            'Every 5 hours',
            'Every 6 hours', 
            'Every 8 hours',
            'Every 10 hours', 
            'Every 12 hours'
        ]
        
        for freq in frequencies:
            btn = RoundedButton(
                text=freq,
                size_hint_y=None,
                height=dp(50),
                bg_color=(0xfd/255, 0xde/255, 0x86/255, 1),  # #fdde86 (yellow)
                text_color=(0, 0, 0, 1),  # Pure black text for maximum contrast
                color=(0, 0, 0, 1)  # Pure black text for maximum contrast
            )
            
            # Set the button's text as the dropdown selection
            btn.bind(on_release=lambda btn: self.frequency_dropdown.select(btn.text))
            self.frequency_dropdown.add_widget(btn)
        
        # Bind the dropdown selection to update the button text
        self.frequency_dropdown.bind(on_select=lambda instance, x: setattr(self.frequency_button, 'text', x))
        
        # Load reminders on startup
        Clock.schedule_once(self.load_reminders, 0.1)
        
        # Now that all UI elements are created, we can call update_theme
        self.update_theme()
        
        # Bind to language changes
        self.language_manager.bind(current_language=self._update_language)
    
    def _update_language(self, *args):
        """Update all UI elements with the current language"""
        # Update all text elements
        self.title_label.text = tr('antibiotic_reminder')
        self.add_text.text = tr('add')
        self.form_title.text = tr('add_new_antibiotic_reminder') if self.is_adding_reminder else tr('edit_antibiotic_reminder')
        self.name_label.text = tr('medication_name')
        self.dosage_label.text = tr('dosage')
        self.frequency_label.text = tr('frequency')
        self.duration_label.text = tr('duration_days')
        self.notes_label.text = tr('notes_optional')
        self.cancel_btn.text = tr('cancel')
        self.save_btn.text = tr('save')
        self.ai_help_btn.text = tr('ask_ai_assistant')
        self.no_reminders_label.text = tr('no_reminders_yet')
        
        # Update input hints
        self.name_input.hint_text = tr('enter_medication_name')
        self.dosage_input.hint_text = tr('enter_dosage')
        if self.frequency_button.text == 'Select frequency':
            self.frequency_button.text = tr('select_frequency')
        self.duration_input.hint_text = tr('enter_duration')
        self.notes_input.hint_text = tr('special_instructions')
        
        # Reload reminders to update their text
        self.load_reminders()
    
    def _update_form_bg(self, *args):
        """Update form background rectangle"""
        self.form_bg.pos = self.form_container.pos
        self.form_bg.size = self.form_container.size
    
    def toggle_frequency_options(self, instance):
        """Show frequency options dropdown"""
        # Only show dropdown if form is visible
        if self.form_visible:
            # First make the entire screen background dark with a semi-transparent overlay
            with self.main_layout.canvas.before:
                Color(0, 0, 0, 0.7)  # Dark semi-transparent overlay
                self.overlay_rect = Rectangle(pos=self.main_layout.pos, size=self.main_layout.size)
                self.main_layout.bind(pos=self._update_overlay, size=self._update_overlay)
            
            # Hide all children of the main layout except form container
            for child in self.main_layout.children:
                if child != self.form_container:
                    child.opacity = 0
            
            # Hide all elements in the form except the frequency button and its parent
            for child in self.form_container.walk(restrict=True):
                if child == self.frequency_button or child == self.frequency_button.parent:
                    continue
                child.opacity = 0
            
            # Calculate better position for dropdown - center in the screen
            window_width, window_height = Window.size
            
            # Create a custom dropdown container in the middle of the screen
            dropdown_width = min(dp(300), window_width * 0.8)
            dropdown_height = min(dp(300), window_height * 0.6)
            
            # Position the dropdown in the center of the screen
            dropdown_x = (window_width - dropdown_width) / 2
            dropdown_y = (window_height - dropdown_height) / 2
            
            # Set dropdown properties with custom style
            self.frequency_dropdown.width = dropdown_width
            self.frequency_dropdown.max_height = dropdown_height
            
            # Clear any previous widgets to rebuild the dropdown with shadow
            self.frequency_dropdown.clear_widgets()
            
            # Create a container for the dropdown with shadow
            dropdown_container = FloatLayout(
                size_hint=(None, None),
                size=(dropdown_width, dropdown_height),
                pos=(dropdown_x, dropdown_y)
            )
            
            # Add shadow effects to the container
            with dropdown_container.canvas.before:
                # Shadow layers for depth effect
                Color(0, 0, 0, 0.3)  # Outer shadow
                RoundedRectangle(
                    pos=(dropdown_x + dp(5), dropdown_y - dp(5)), 
                    size=(dropdown_width, dropdown_height),
                    radius=[dp(10)]
                )
                
                Color(0, 0, 0, 0.4)  # Middle shadow
                RoundedRectangle(
                    pos=(dropdown_x + dp(3), dropdown_y - dp(3)), 
                    size=(dropdown_width, dropdown_height),
                    radius=[dp(10)]
                )
                
                # Background color based on theme
                if self.theme_manager.is_dark_mode:
                    Color(0x22/255, 0x22/255, 0x26/255, 1)  # Dark gray - #222226
                else:
                    Color(0.95, 0.95, 0.97, 1)  # Light background
                
                # Main background
                RoundedRectangle(
                    pos=(dropdown_x, dropdown_y),
                    size=(dropdown_width, dropdown_height),
                    radius=[dp(10)]
                )
            
            # Create a ScrollView for the options
            scroll_view = ScrollView(
                size_hint=(None, None),
                size=(dropdown_width - dp(10), dropdown_height - dp(10)),
                pos=(dropdown_x + dp(5), dropdown_y + dp(5)),
            )
            
            # Create a vertical layout for the options
            options_layout = GridLayout(
                cols=1,
                spacing=dp(2),
                size_hint_y=None
            )
            options_layout.bind(minimum_height=options_layout.setter('height'))
            
            # Add title
            title_label = Label(
                text="Select Frequency",
                size_hint_y=None,
                height=dp(40),
                font_size=dp(16),
                bold=True,
                color=(0.9, 0.9, 0.9, 1) if self.theme_manager.is_dark_mode else (0.1, 0.1, 0.1, 1)
            )
            options_layout.add_widget(title_label)
            
            # Frequency options
            frequencies = [
                'Once daily', 
                'Twice daily', 
                'Three times daily', 
                'Four times daily',
                'Every 1 hour',
                'Every 2 hours',
                'Every 3 hours',
                'Every 4 hours',
                'Every 5 hours',
                'Every 6 hours', 
                'Every 8 hours',
                'Every 10 hours', 
                'Every 12 hours'
            ]
            
            # Add all frequency options
            for freq in frequencies:
                btn = RoundedButton(
                    text=freq,
                    size_hint_y=None,
                    height=dp(50),
                    bg_color=(0x2a/255, 0x2a/255, 0x2e/255, 1) if self.theme_manager.is_dark_mode else (0xfd/255, 0xde/255, 0x86/255, 1),
                    text_color=(0.9, 0.9, 0.9, 1) if self.theme_manager.is_dark_mode else (0, 0, 0, 1)
                )
                
                # When clicked, update the frequency button text and dismiss
                def create_callback(text):
                    def callback(instance):
                        self.frequency_button.text = text
                        self._on_dropdown_dismiss(None)
                    return callback
                
                btn.bind(on_release=create_callback(freq))
                options_layout.add_widget(btn)
            
            # Add cancel button at the bottom
            cancel_btn = RoundedButton(
                text="Cancel",
                size_hint_y=None,
                height=dp(50),
                bg_color=(0.7, 0.3, 0.3, 1),
                text_color=(1, 1, 1, 1)
            )
            cancel_btn.bind(on_release=lambda x: self._on_dropdown_dismiss(None))
            options_layout.add_widget(cancel_btn)
            
            # Add everything to the container
            scroll_view.add_widget(options_layout)
            self.main_layout.add_widget(dropdown_container)
            self.main_layout.add_widget(scroll_view)
            
            # Store references to remove them later
            self.dropdown_container = dropdown_container
            self.dropdown_scroll = scroll_view
    
    def _update_overlay(self, instance, value):
        """Update overlay rectangle position and size"""
        if hasattr(self, 'overlay_rect'):
            self.overlay_rect.pos = instance.pos
            self.overlay_rect.size = instance.size
    
    def _on_dropdown_dismiss(self, instance):
        """Callback when dropdown is dismissed to restore content"""
        # Remove the dark overlay
        if hasattr(self, 'overlay_rect'):
            self.main_layout.canvas.before.remove(self.overlay_rect)
            delattr(self, 'overlay_rect')
        
        # Remove custom dropdown components if they exist
        if hasattr(self, 'dropdown_container'):
            self.main_layout.remove_widget(self.dropdown_container)
            delattr(self, 'dropdown_container')
            
        if hasattr(self, 'dropdown_scroll'):
            self.main_layout.remove_widget(self.dropdown_scroll)
            delattr(self, 'dropdown_scroll')
        
        # Restore visibility of all main layout children
        for child in self.main_layout.children:
            child.opacity = 1
        
        # Restore visibility of all form elements
        for child in self.form_container.walk(restrict=True):
            child.opacity = 1
    
    def load_reminders(self, dt=None):
        """Load reminders from persistent storage"""
        try:
            # Clear existing reminders
            self.reminders_layout.clear_widgets()
            
            # Load reminders from JSON file
            reminders = []
            if os.path.exists('reminders.json'):
                with open('reminders.json', 'r') as f:
                    reminders = json.load(f)
            
            # Sort reminders by next dose time, handling None values
            def get_sort_key(reminder):
                next_time = reminder.get('next_time')
                if next_time is None:
                    return datetime.min.isoformat()  # Put None values at the end
                try:
                    return next_time
                except (ValueError, TypeError):
                    return datetime.min.isoformat()
            
            reminders.sort(key=get_sort_key, reverse=True)
            
            # Check if there are truly no reminders
            if not reminders:
                self.no_reminders_label.opacity = 1
            else:
                self.no_reminders_label.opacity = 0
                
                # Create reminder cards
                for reminder in reminders:
                    # Convert next_time string back to datetime if it exists
                    if reminder.get('next_time'):
                        try:
                            next_time = datetime.fromisoformat(reminder['next_time'])
                            # If the next dose time is in the past, reset it
                            if next_time < datetime.now():
                                reminder['next_time'] = None
                            else:
                                reminder['next_time'] = next_time.isoformat()
                        except (ValueError, TypeError):
                            reminder['next_time'] = None
                    
                    card = ReminderCard(reminder)
                    self.reminders_layout.add_widget(card)
                    
                print(f"Loaded {len(reminders)} reminders")
                
        except Exception as e:
            print(f"Error loading reminders: {e}")

    def show_add_reminder(self, instance):
        """Show the add reminder form"""
        self.is_adding_reminder = True
        self.editing_reminder_id = ''
        self.form_title.text = tr("add_new_antibiotic_reminder")
        self.save_btn.text = tr("save")
        
        # Clear form fields
        self.name_input.text = ''
        self.dosage_input.text = ''
        self.frequency_button.text = tr('select_frequency')
        self.duration_input.text = ''
        self.notes_input.text = ''
        
        # Show form, hide reminders
        self.form_container.opacity = 1
        self.form_visible = True
        self.scroll_view.opacity = 0
        self.no_reminders_label.opacity = 0

        # Enable AI help button
        if hasattr(self, 'ai_help_btn'):
            self.ai_help_btn.disabled = False
    
    def show_edit_reminder(self, reminder_id):
        """Show the edit reminder form"""
        # Load reminders from JSON file
        reminders = []
        if os.path.exists('reminders.json'):
            with open('reminders.json', 'r') as f:
                reminders = json.load(f)
        reminder = next((r for r in reminders if r.get('id') == reminder_id), None)
        if not reminder:
            return
        self.is_adding_reminder = False
        self.editing_reminder_id = reminder_id
        self.form_title.text = tr("edit_antibiotic_reminder")
        self.save_btn.text = 'Update'
        # Fill form fields with reminder data
        self.name_input.text = reminder.get('medication_name', '')
        self.dosage_input.text = reminder.get('dosage', '')
        self.frequency_button.text = reminder.get('frequency', tr('select_frequency'))
        self.duration_input.text = str(reminder.get('duration', ''))
        self.notes_input.text = reminder.get('notes', '')
        # Show form, hide reminders
        self.form_container.opacity = 1
        self.form_visible = True
        self.scroll_view.opacity = 0
        self.no_reminders_label.opacity = 0
        if hasattr(self, 'ai_help_btn'):
            self.ai_help_btn.disabled = False

    def delete_reminder(self, reminder_id):
        """Delete a reminder from reminders.json by ID"""
        reminders = []
        if os.path.exists('reminders.json'):
            with open('reminders.json', 'r') as f:
                reminders = json.load(f)
        reminders = [r for r in reminders if r.get('id') != reminder_id]
        with open('reminders.json', 'w') as f:
            json.dump(reminders, f)
        self.load_reminders()

    def hide_form(self, instance=None):
        """Hide the add/edit reminder form"""
        # Hide form, show reminders
        self.form_container.opacity = 0
        self.form_visible = False
        self.scroll_view.opacity = 1
        
        # Disable AI help button
        if hasattr(self, 'ai_help_btn'):
            self.ai_help_btn.disabled = True
        
        # Show no reminders message if needed
        if not self.reminders_layout.children:
            self.no_reminders_label.opacity = 1
    
    def save_reminder(self, instance):
        """Save or update reminder data to persistent storage"""
        try:
            # Validate required fields only when saving
            if not self.name_input.text.strip():
                print("Medication name is required")
                return
            reminders = []
            if os.path.exists('reminders.json'):
                with open('reminders.json', 'r') as f:
                    reminders = json.load(f)
            if self.is_adding_reminder or not self.editing_reminder_id:
                # Create new reminder
                reminder_data = {
                    'id': str(uuid.uuid4()),
                    'medication_name': self.name_input.text.strip(),
                    'frequency': self.frequency_button.text,
                    'duration': int(self.duration_input.text) if self.duration_input.text.isdigit() else 1,
                    'dosage': self.dosage_input.text.strip(),
                    'notes': self.notes_input.text.strip(),
                    'doses_taken': 0,
                    'next_time': None
                }
                reminders.append(reminder_data)
            else:
                # Update existing reminder
                for reminder in reminders:
                    if reminder.get('id') == self.editing_reminder_id:
                        reminder['medication_name'] = self.name_input.text.strip()
                        reminder['frequency'] = self.frequency_button.text
                        reminder['duration'] = int(self.duration_input.text) if self.duration_input.text.isdigit() else 1
                        reminder['dosage'] = self.dosage_input.text.strip()
                        reminder['notes'] = self.notes_input.text.strip()
                        break
            with open('reminders.json', 'w') as f:
                json.dump(reminders, f)
            print(f"Saved reminder(s)")
            self.hide_form()
            self.load_reminders()
        except Exception as e:
            print(f"Error saving reminder: {e}")

    def ask_ai_about_medication(self, instance):
        """Open the Voice/AI screen with context about the current medication"""
        # Safety check: only proceed if the form is visible
        if not self.form_visible:
            print("Form not visible, ignoring AI assistant request")
            return
            
        from kivy.app import App
        app = App.get_running_app()
        
        # Get medication name from form
        medication_name = self.name_input.text.strip()
        
        print(f"Opening AI assistant with medication: {medication_name if medication_name else 'no specific medication'}")
            
        try:
            # Explicitly create a new VoiceScreen instance
            voice_screen = VoiceScreen(name='voice')
            
            # Set the medication context only if provided
            if medication_name:
                voice_screen.set_medication_context(medication_name)
            
            # Get the screen manager
            sm = app.root
            
            # Check if voice screen already exists and replace it
            if 'voice' in sm.screen_names:
                sm.remove_widget(sm.get_screen('voice'))
            
            # Add the new voice screen
            sm.add_widget(voice_screen)
            
            # Hide the form before navigating
            self.hide_form()
            
            # Navigate to the voice screen
            print("Switching to voice screen")
            sm.current = 'voice'
            
        except Exception as e:
            import traceback
            print(f"Error navigating to voice screen: {e}")
            traceback.print_exc()
            
            # Show error message to user
            self.status_label = Label(
                text="Could not open AI assistant. Please try again.",
                font_size=dp(14),
                color=(0.9, 0.3, 0.3, 1),  # Red text
                size_hint=(1, None),
                height=dp(30),
                pos_hint={'center_x': 0.5, 'center_y': 0.9}
            )
            # Find the form grid and add the message
            for child in self.form_container.children:
                if isinstance(child, GridLayout):
                    child.add_widget(self.status_label, 1)
                    # Remove after 3 seconds
                    Clock.schedule_once(lambda dt: child.remove_widget(self.status_label), 3)
                    break
    
    def update_theme(self, *args):
        """Update colors based on current theme"""
        # Call parent's update_theme
        super(ReminderScreen, self).update_theme(*args)
        
        # Get theme colors
        colors = self.theme_manager.get_colors()
        is_dark = self.theme_manager.is_dark_mode
        
        # Update UI elements specific to this screen
        
        # Title label
        if hasattr(self, 'title_label'):
            self.title_label.color = colors['text']
            
        # Form background
        if hasattr(self, 'form_bg_color'):
            self.form_bg_color.rgba = colors['background']
            
        # Update form labels
        for name in ['name_label', 'dosage_label', 'frequency_label', 'duration_label', 'notes_label']:
            if hasattr(self, name):
                getattr(self, name).color = colors['text']
                
        # Update form inputs
        for name in ['name_input', 'dosage_input', 'duration_input', 'notes_input']:
            if hasattr(self, name):
                input_elem = getattr(self, name)
                input_elem.background_color = colors['input_bg']
                input_elem.foreground_color = colors['text']
                input_elem.cursor_color = colors['primary']
                
        # Update frequency button
        if hasattr(self, 'frequency_button'):
            self.frequency_button.text = 'Update'
            if is_dark:
                self.frequency_button.bg_color = (0.18, 0.18, 0.22, 1)  # Dark grey for dark mode
            else:
                self.frequency_button.bg_color = (0xfd/255, 0xde/255, 0x86/255, 1)  # Previous yellow (like a mandarin)
            self.frequency_button.color = (0.1, 0.1, 0.1, 1) if not is_dark else (1, 1, 1, 1)  # Adjust text color for contrast
            if hasattr(self.frequency_button, '_update_canvas'):
                self.frequency_button._update_canvas()
        
        # Update frequency dropdown buttons
        if hasattr(self, 'frequency_dropdown'):
            for child in self.frequency_dropdown.children:
                if isinstance(child, Button):
                    if is_dark:
                        if hasattr(child, 'bg_color'):
                            child.bg_color = (0.6, 0.55, 0.2, 1)  # Match frequency button color in dark mode
                        else:
                            child.background_color = (0.6, 0.55, 0.2, 1)
                        child.color = (1, 1, 1, 1)  # White text
                    else:
                        if hasattr(child, 'bg_color'):
                            child.bg_color = (0xfd/255, 0xde/255, 0x86/255, 1)  # Match frequency button color
                        else:
                            child.background_color = (0xfd/255, 0xde/255, 0x86/255, 1)
                        child.color = (0.2, 0.2, 0.2, 1)  # Dark text
                    
        # Update buttons
        if hasattr(self, 'cancel_btn'):
            self.cancel_btn.color = (1, 1, 1, 1)  # White text
            # Keep red color but adjust for dark mode
            if is_dark:
                self.cancel_btn.bg_color = (0.7, 0.2, 0.2, 1)  # Darker red for dark mode
            else:
                self.cancel_btn.bg_color = (0.9, 0.3, 0.3, 1)  # Original red
            
        if hasattr(self, 'save_btn'):
            # Keep green but adjust for dark mode
            if is_dark:
                self.save_btn.bg_color = (0.1, 0.5, 0.2, 1)  # Darker green
            else:
                self.save_btn.bg_color = (0.2, 0.7, 0.3, 1)  # Original green
            self.save_btn.color = (1, 1, 1, 1)  # White text
            if hasattr(self.save_btn, '_update_canvas'):
                self.save_btn._update_canvas()
        
        if hasattr(self, 'ai_help_btn'):
            # Adjust purple for dark mode
            if is_dark:
                self.ai_help_btn.bg_color = (0.3, 0.2, 0.6, 1)  # Darker purple
            else:
                self.ai_help_btn.bg_color = (0.5, 0.3, 0.9, 1)  # Original purple
            self.ai_help_btn.color = (1, 1, 1, 1)  # White text
            
        # No reminders label
        if hasattr(self, 'no_reminders_label'):
            self.no_reminders_label.color = colors['text_secondary'] if 'text_secondary' in colors else (0.6, 0.6, 0.6, 1)
            
        # Update add button and text
        if hasattr(self, 'circle_plus_btn'):
            # Keep green but adjust for dark mode
            if is_dark:
                self.circle_plus_btn.bg_color = (0.1, 0.5, 0.2, 1)  # Darker green
            else:
                self.circle_plus_btn.bg_color = (0.2, 0.7, 0.3, 1)  # Original green
            self.circle_plus_btn.fg_color = (1, 1, 1, 1)  # Always white text
                
        if hasattr(self, 'add_text'):
            if is_dark:
                self.add_text.color = (0.1, 0.5, 0.2, 1)  # Darker green
            else:
                self.add_text.color = (0.2, 0.7, 0.3, 1)  # Original green
                
        # Update all reminder cards
        for child in self.reminders_layout.children:
            if isinstance(child, ReminderCard) and hasattr(child, 'update_theme'):
                child.update_theme()

    def add_message(self, text, is_user=True):
        """Add a message bubble to the chat"""
        # Create a new chat bubble
        bubble = ChatBubble(text, is_user=is_user)
        
        # Add to the chat layout at the bottom
        self.chat_layout.add_widget(bubble)
        
        # Scroll to the bottom to show the new message
        self._scroll_to_bottom()

    def _scroll_to_bottom(self, *args):
        if hasattr(self, 'scroll_view') and hasattr(self, 'chat_layout'):
            self.scroll_view.scroll_y = 0

# Camera Screen - Shows the bars
class MediScanScreen(BaseScreen):
    def __init__(self, **kwargs):
        # First initialize the parent BaseScreen
        try:
            super(MediScanScreen, self).__init__(**kwargs)
        except Exception as e:
            print(f"Error initializing MediScanScreen: {e}")
            return
            
        try:
            # Add title with improved styling
            title = Label(
                text='MediScan',
                font_size=dp(24),
                bold=True,
                color=(0.2, 0.4, 0.8, 1),  # Blue text
                pos_hint={'center_x': 0.5, 'top': 0.95}
            )
            self.main_layout.add_widget(title)
            
            # Add camera content
            content = Label(
                text='This feature will allow you to scan and identify medications using your camera.\n\nComing in the next update!',
                font_size=dp(18),
                color=(0.3, 0.3, 0.3, 1),
                halign='center',
                pos_hint={'center_x': 0.5, 'center_y': 0.5}
            )
            self.main_layout.add_widget(content)
            
            # Add camera icon in a circular container for visual appeal
            icon_container = FloatLayout(
                size_hint=(None, None),
                size=(dp(120), dp(120)),
                pos_hint={'center_x': 0.5, 'center_y': 0.7}
            )
            
            # Add circular background
            with icon_container.canvas.before:
                Color(0.95, 0.95, 1, 1)  # Light blue background
                Ellipse(pos=(0, 0), size=(dp(120), dp(120)))
            
            # Add camera icon
            try:
                camera_icon = Image(
                    source='icons/x-ray.png',  # Changed from camera.png to x-ray.png
                    size_hint=(None, None),
                    size=(dp(80), dp(80)),
                    pos_hint={'center_x': 0.5, 'center_y': 0.5}
                )
                icon_container.add_widget(camera_icon)
            except Exception as e:
                print(f"Error loading camera icon: {e}")
                # Add a fallback label if image fails to load
                fallback = Label(text="📷", font_size=dp(40))
                icon_container.add_widget(fallback)
                
            self.main_layout.add_widget(icon_container)
            
            # Add a coming soon button
            coming_soon = Button(
                text="Coming Soon",
                size_hint=(0.5, None),
                height=dp(50),
                pos_hint={'center_x': 0.5, 'center_y': 0.3},
                background_normal='',
                background_color=(0.7, 0.7, 0.7, 1),
                color=(1, 1, 1, 1)
            )
            self.main_layout.add_widget(coming_soon)
            
        except Exception as e:
            # If anything fails, add an error message instead of crashing
            print(f"Error setting up MediScanScreen: {e}")
            error_label = Label(
                text=f"Sorry, there was an error loading this screen.\nPlease try again later.",
                font_size=dp(18),
                color=(0.8, 0.3, 0.3, 1),  # Red text
                halign='center',
                pos_hint={'center_x': 0.5, 'center_y': 0.5}
            )
            self.main_layout.add_widget(error_label)

# Voice Assistant Screen with AI integration
from kivy.animation import Animation
from kivy.uix.behaviors import ToggleButtonBehavior
from kivy.core.window import Window
from kivy.clock import Clock
from datetime import datetime
import threading

# Try to import the full-featured AI assistant first
try:
    from ai_assistant import AIAssistant
    HAS_FULL_AI = True
except ImportError:
    HAS_FULL_AI = False
    
# Try to import the simplified AI assistant as fallback
try:
    from ai_assistant import SimpleAIAssistant
    HAS_SIMPLE_AI = True
except ImportError:
    HAS_SIMPLE_AI = False

class PulsingMicButton(ToggleButtonBehavior, BoxLayout):
    def __init__(self, **kwargs):
        super(PulsingMicButton, self).__init__(**kwargs)
        self.orientation = 'vertical'
        self.size_hint = (None, None)
        self.size = (dp(80), dp(120))
        self.pos_hint = {'center_x': 0.5, 'center_y': 0.15}  # Moved up from 0.3 to 0.15
        self.spacing = dp(5)
        
        # Create the microphone icon container
        self.icon_container = FloatLayout(
            size_hint=(None, None),
            size=(dp(70), dp(70)),  # Reduced from (100, 100)
            pos_hint={'center_x': 0.5, 'top': 1}
        )
        
        # Add circular background
        with self.icon_container.canvas.before:
            Color(0.95, 0.95, 0.95, 1)  # Light gray
            self.bg_circle = Ellipse(
                pos=(self.icon_container.center_x - dp(35), self.icon_container.center_y - dp(35)),  # Adjusted for new size
                size=(dp(70), dp(70))  # Reduced from (100, 100)
            )
        self.icon_container.bind(pos=self._update_ellipse, size=self._update_ellipse)
        
        # Add microphone icon
        self.mic_icon = Image(
            source='icons/microphone.png',
            size_hint=(None, None),
            size=(dp(40), dp(40)),  # Reduced from (60, 60)
            pos_hint={'center_x': 0.5, 'center_y': 0.5}
        )
        self.icon_container.add_widget(self.mic_icon)
        self.add_widget(self.icon_container)
        
        # Add label
        self.label = Label(
            text='Tap to speak',
            font_size=dp(14),  # Reduced from 16
            color=(0.3, 0.3, 0.3, 1),
            bold=True,
            size_hint=(1, None),
            height=dp(25)  # Reduced from 30
        )
        self.add_widget(self.label)
        
        # Set initial state
        self.pulsing_animation = None
        self.state = 'normal'
    
    def _update_ellipse(self, *args):
        self.bg_circle.pos = (
            self.icon_container.x + (self.icon_container.width - dp(70)) / 2,
            self.icon_container.y + (self.icon_container.height - dp(70)) / 2
        )
    
    def on_state(self, instance, value):
        if value == 'down':
            # Start pulsing animation
            self._start_pulsing()
            self.label.text = 'Listening...'
            self.label.color = (0.9, 0.3, 0.3, 1)  # Red text
        else:
            # Stop pulsing animation
            self._stop_pulsing()
            self.label.text = 'Tap to speak'
            self.label.color = (0.3, 0.3, 0.3, 1)  # Gray text
    
    def _start_pulsing(self):
        # Create pulsing animation for the background circle
        scale_up = Animation(
            size=(dp(75), dp(75)), 
            pos=(
                self.icon_container.center_x - dp(37.5), 
                self.icon_container.center_y - dp(37.5)
            ), 
            duration=0.7
        )
        scale_down = Animation(
            size=(dp(70), dp(70)), 
            pos=(
                self.icon_container.center_x - dp(35), 
                self.icon_container.center_y - dp(35)
            ), 
            duration=0.7
        )
        self.pulsing_animation = scale_up + scale_down
        self.pulsing_animation.repeat = True
        self.pulsing_animation.start(self.bg_circle)
        
        # Change background color to indicate recording
        with self.icon_container.canvas.before:
            Color(0.9, 0.3, 0.3, 0.2)  # Light red
            self.bg_circle = Ellipse(
                pos=(self.icon_container.center_x - dp(35), self.icon_container.center_y - dp(35)), 
                size=(dp(70), dp(70))
            )
    
    def _stop_pulsing(self):
        if self.pulsing_animation:
            self.pulsing_animation.cancel(self.bg_circle)
            self.pulsing_animation = None
        
        # Reset background color
        with self.icon_container.canvas.before:
            Color(0.95, 0.95, 0.95, 1)  # Light gray
            self.bg_circle = Ellipse(
                pos=(self.icon_container.center_x - dp(35), self.icon_container.center_y - dp(35)), 
                size=(dp(70), dp(70))
            )

class ChatBubble(BoxLayout):
    def __init__(self, message, is_user=False, **kwargs):
        super(ChatBubble, self).__init__(**kwargs)
        self.orientation = 'horizontal'
        self.size_hint_y = None
        self.padding = [dp(10), dp(5)]
        self.spacing = dp(10)
        self.is_user = is_user
        self.message = message
        self.label = None
        self.bubble = None
        self.rect = None
        self._build_bubble()
        # Listen for theme changes
        from theme_manager import ThemeManager
        self.theme_manager = ThemeManager()
        self.theme_manager.bind(is_dark_mode=lambda *_: self._redraw_bubble())

    def _build_bubble(self):
        text_width = Window.width * 0.65  # Slightly narrower than before (was 0.34)
        from theme_manager import ThemeManager
        theme_manager = ThemeManager()
        is_dark = theme_manager.is_dark_mode
        label_color = (1, 1, 1, 1) if self.is_user else ((0.9, 0.9, 0.9, 1) if is_dark else (0.1, 0.1, 0.1, 1))
        self.label = Label(
            text=self.message,
            size_hint_x=None,
            width=text_width,
            text_size=(text_width, None),
            halign='left',
            valign='middle',
            padding=[dp(15), dp(10)],
            color=label_color,
            markup=True,
            shorten=False,
            shorten_from='right',
            split_str='\n'
        )
        self.label.bind(texture_size=self._update_size)
        self.bubble = BoxLayout(
            size_hint=(0.8, 1),
            pos_hint={'right': 1} if self.is_user else {'x': 0}
        )
        self._redraw_bubble()
        self.bubble.bind(size=self._update_rect, pos=self._update_rect)
        self.bubble.add_widget(self.label)
        if self.is_user:
            self.add_widget(Widget(size_hint_x=0.2))
            self.add_widget(self.bubble)
        else:
            self.add_widget(self.bubble)
            self.add_widget(Widget(size_hint_x=0.2))

    def _redraw_bubble(self):
        self.bubble.canvas.before.clear()
        from theme_manager import ThemeManager
        theme_manager = ThemeManager()
        is_dark = theme_manager.is_dark_mode
        if self.is_user:
            color = (0.2, 0.6, 0.9, 1)  # Blue for user messages
            label_color = (1, 1, 1, 1)
        else:
            color = (0.18, 0.18, 0.22, 1) if is_dark else (0.95, 0.95, 0.95, 1)
            label_color = (0.9, 0.9, 0.9, 1) if is_dark else (0.1, 0.1, 0.1, 1)
        with self.bubble.canvas.before:
            Color(*color)
            self.rect = RoundedRectangle(size=self.bubble.size, pos=self.bubble.pos, radius=[dp(15)])
        if self.label:
            self.label.color = label_color

    def _update_size(self, instance, value):
        # Update height based on text content
        self.height = value[1] + dp(20)  # Text height + padding

    def _update_rect(self, instance, value):
        self.rect.size = instance.size
        self.rect.pos = instance.pos

class VoiceScreen(BaseScreen):
    def __init__(self, **kwargs):
        super(VoiceScreen, self).__init__(auto_update_theme=False, **kwargs)
        self.language_manager = LanguageManager()
        
        # Initialize AI assistant with proper fallback mechanisms
        self.ai_assistant = None
        
        # Try to initialize AI assistant
        try:
            # First try to use the full AI assistant with API
            from ai_assistant import AIAssistant
            
            # Check if the API key is valid
            api_key_file = 'openai_api_key.txt'
            if os.path.exists(api_key_file):
                with open(api_key_file, 'r') as f:
                    api_key = f.read().strip()
                    if api_key and 'YOUR_API_KEY' not in api_key:
                        self.ai_assistant = AIAssistant(api_key)
        except Exception as e:
            print(f"Error initializing AIAssistant: {e}")
            
        # If full AI assistant failed, use the simple version
        if not self.ai_assistant:
            try:
                from ai_assistant import SimpleAIAssistant
                self.ai_assistant = SimpleAIAssistant()
                
                # Set up a direct binding to detect when the reminder event changes
                if hasattr(self.ai_assistant, 'create_reminder_event'):
                    print("Setting up reminder event binding")
                    self.ai_assistant.bind(create_reminder_event=self._on_reminder_event_change)
                    
            except Exception as e:
                print(f"Error initializing SimpleAIAssistant: {e}")
                self.ai_assistant = None
        
        # Track if we're currently processing voice input
        self.is_listening = False
        self.is_processing = False
        self.medication_context = None
        
        # Add title with subtitle
        title_box = BoxLayout(
            orientation='vertical',
            size_hint=(1, None),
            height=dp(60),
            pos_hint={'center_x': 0.5, 'top': 0.98},
            spacing=dp(2)
        )
        
        self.title_label = Label(
            text=tr('medical_assistant'),
            font_size=dp(24),
            bold=True,
            color=(0.2, 0.4, 0.8, 1),  # Blue
            size_hint=(1, None),
            height=dp(30)
        )
        
        self.subtitle_label = Label(
            text=tr('ask_about_medication'),
            font_size=dp(14),
            italic=True,
            color=(0.5, 0.5, 0.5, 1),  # Gray
            size_hint=(1, None),
            height=dp(20)
        )
        
        title_box.add_widget(self.title_label)
        title_box.add_widget(self.subtitle_label)
        self.main_layout.add_widget(title_box)
        
        # Chat history scroll view
        self.scroll_view = ScrollView(
            size_hint=(1, None),
            height=Window.height * 0.6,  # Increased from 0.6 to 0.72
            pos_hint={'center_x': 0.5, 'top': 0.89}  # Lowered to extend chat area
        )
        
        # This will hold our chat bubbles
        self.chat_layout = GridLayout(
            cols=1,
            spacing=dp(15),
            padding=[dp(10), dp(10), dp(10), dp(20)],
            size_hint_y=None
        )
        self.chat_layout.bind(minimum_height=self.chat_layout.setter('height'))
        
        self.scroll_view.add_widget(self.chat_layout)
        self.main_layout.add_widget(self.scroll_view)
        
        # Status label above mic button
        self.status_label = Label(
            text='',
            font_size=dp(14),
            italic=True,
            color=(0.5, 0.5, 0.5, 1),
            size_hint=(1, None),
            height=dp(20),
            pos_hint={'center_x': 0.5, 'center_y': 0.27}  # Adjusted to be above mic button
        )
        self.main_layout.add_widget(self.status_label)
        
        # Add microphone button below status label
        self.mic_button = PulsingMicButton()
        self.mic_button.pos_hint = {'center_x': 0.5, 'center_y': 0.19}  # Adjusted to be above input field
        self.mic_button.bind(on_press=self.toggle_listening)
        self.main_layout.add_widget(self.mic_button)
        
        # Add input area below mic button
        input_area = BoxLayout(
            orientation='horizontal',
            size_hint=(1, None),
            height=dp(60),
            padding=[dp(10), dp(5)],
            spacing=dp(10),
            pos_hint={'center_x': 0.5, 'y': 0.02}
        )
        # Text input
        self.text_input = TextInput(
            hint_text=tr('type_message_here'),
            size_hint=(0.8, None),
            height=dp(50),
            multiline=False,
            padding=[dp(10), dp(10), dp(10), 0],
            font_size=dp(16)
        )
        self.text_input.bind(on_text_validate=self.send_text_message)
        
        # Container for the send button
        send_container = BoxLayout(
            orientation='vertical',
            size_hint=(0.2, None),
            height=dp(50)
        )
        # Custom IconButton for send
        class IconButton(ButtonBehavior, BoxLayout):
            def __init__(self, **kwargs):
                super(IconButton, self).__init__(**kwargs)
                self.orientation = 'vertical'
                with self.canvas.before:
                    Color(0.36, 0.56, 0.85, 1)  # Blue border
                    self.border = RoundedRectangle(pos=self.pos, size=self.size, radius=[dp(8)])
                    Color(1, 1, 1, 1)  # White background
                    border_width = dp(2)
                    self.bg = RoundedRectangle(
                        pos=(self.x + border_width, self.y + border_width),
                        size=(self.width - 2*border_width, self.height - 2*border_width),
                        radius=[dp(6)]
                    )
                self.bind(pos=self._update_rect, size=self._update_rect)
            def _update_rect(self, *args):
                self.border.pos = self.pos
                self.border.size = self.size
                border_width = dp(2)
                self.bg.pos = (self.x + border_width, self.y + border_width)
                self.bg.size = (self.width - 2*border_width, self.height - 2*border_width)
            def on_press(self):
                self.canvas.before.clear()
                with self.canvas.before:
                    Color(0.36, 0.56, 0.85, 1)
                    self.border = RoundedRectangle(pos=self.pos, size=self.size, radius=[dp(8)])
                    Color(0.9, 0.9, 0.9, 1)
                    border_width = dp(2)
                    self.bg = RoundedRectangle(
                        pos=(self.x + border_width, self.y + border_width),
                        size=(self.width - 2*border_width, self.height - 2*border_width),
                        radius=[dp(6)]
                    )
        # Create our custom button
        self.send_btn = IconButton(size_hint=(1, 1))
        # Centered icon
        icon_layout = AnchorLayout(
            anchor_x='center',
            anchor_y='center',
            size_hint=(1, 1)
        )
        self.send_icon = Image(
            source='icons/send.png',
            size_hint=(None, None),
            size=(dp(26), dp(26))
        )
        icon_layout.add_widget(self.send_icon)
        self.send_btn.add_widget(icon_layout)
        self.send_btn.bind(on_release=self.send_text_message)
        send_container.add_widget(self.send_btn)
        # Add to input area
        input_area.add_widget(self.text_input)
        input_area.add_widget(send_container)
        self.main_layout.add_widget(input_area)
        
        # Add a welcome message from the AI after a small delay
        Clock.schedule_once(self.add_welcome_message, 0.5)
        
        # Bind to language changes for updating text
        self.language_manager.bind(current_language=self._update_language)
        
        # Now that all UI elements are created, we can call update_theme
        self.update_theme()

    def _update_language(self, *args):
        """Update all UI text based on the current language"""
        # Update static UI elements
        self.title_label.text = tr('medical_assistant')
        self.subtitle_label.text = tr('ask_about_medication')
        self.text_input.hint_text = tr('type_message_here')
        self.send_btn.text = tr('send')
        
        # Update welcome message if it hasn't been sent yet
        if not self.chat_layout.children:
            Clock.schedule_once(self.add_welcome_message, 0.1)

    def add_welcome_message(self, dt=None):
        """Add an initial welcome message from the AI assistant"""
        if self.medication_context:
            welcome_text = f"Hello! I see you're asking about {self.medication_context}. How can I help you with this medication today?"
        else:
            welcome_text = tr('welcome_message')
        
        self.add_message(welcome_text, is_user=False)

    def set_medication_context(self, medication_name):
        """Set context about a specific medication"""
        self.medication_context = medication_name
        
        # If we already have messages, add a new one about the medication
        if self.chat_layout.children:
            self.add_message(f"I see you want to know more about {medication_name}. What would you like to know about this medication?", is_user=False)
    
    def _scroll_to_bottom(self):
        """Scroll the chat view to the bottom"""
        if self.chat_layout.height > self.scroll_view.height:
            self.scroll_view.scroll_y = 0

    def toggle_listening(self, instance):
        """Toggle voice listening mode"""
        if not self.ai_assistant:
            self.status_label.text = tr('assistant_not_available')
            self.mic_button.state = 'normal'
            return
        
        if self.is_listening:
            # Stop listening
            self.is_listening = False
            self.mic_button.state = 'normal'
            self.status_label.text = "Processing..."
        else:
            # Start listening
            self.is_listening = True
            self.mic_button.state = 'down'
            self.status_label.text = "Listening..."
            
            # Start the speech recognition process
            self._start_voice_input()
    
    def _start_voice_input(self):
        """Start the speech recognition process in a separate thread"""
        try:
            if self.ai_assistant:
                # Monitor the AI assistant's is_listening property
                def check_listening_status(dt):
                    try:
                        if not self.ai_assistant.is_listening:
                            # Speech recognition completed
                            self.is_listening = False
                            self.mic_button.state = 'normal'
                            
                            # Safety check to ensure we don't access attributes that don't exist
                            if hasattr(self.ai_assistant, 'response_text'):
                                response_text = self.ai_assistant.response_text
                                
                                if (response_text.startswith("I couldn't understand") or 
                                    response_text.startswith("I didn't hear") or
                                    response_text.startswith("Error")):
                                    # Error in speech recognition
                                    self.status_label.text = response_text
                                    Clock.schedule_once(lambda dt: setattr(self.status_label, 'text', ''), 3)
                                elif hasattr(self.ai_assistant, 'recognized_text') and self.ai_assistant.recognized_text:
                                    # Add the recognized text as a user message
                                    self.add_message(self.ai_assistant.recognized_text, is_user=True)
                                    
                                    # Process with AI and add response
                                    self._process_ai_response()
                            return False  # Stop checking
                        return True  # Continue checking
                    except Exception as e:
                        print(f"Error in check_listening_status: {e}")
                        self.status_label.text = "An error occurred while listening"
                        self.is_listening = False
                        self.mic_button.state = 'normal'
                        return False  # Stop checking on error
                
                # Start the speech recognition with error handling
                try:
                    self.ai_assistant.start_voice_input()
                except Exception as e:
                    print(f"Error starting voice input: {e}")
                    self.status_label.text = "Could not start speech recognition"
                    self.is_listening = False
                    self.mic_button.state = 'normal'
                    return
                
                # Check status periodically until no longer listening
                Clock.schedule_interval(check_listening_status, 0.5)
            else:
                # Handle case when AI assistant is not available
                self.status_label.text = "Speech recognition not available"
                self.is_listening = False
                self.mic_button.state = 'normal'
                
                # Add a fallback message in the chat
                self.add_message("Sorry, I couldn't access the speech recognition system. Please type your message instead.", is_user=False)
        except Exception as e:
            print(f"Error in _start_voice_input: {e}")
            self.status_label.text = "An error occurred"
            self.is_listening = False
            if hasattr(self, 'mic_button'):
                self.mic_button.state = 'normal'
    
    def _process_voice_input(self, recognized_text):
        """Process the recognized text from voice input"""
        if not recognized_text:
            self.add_message("I didn't hear anything. Please try again.", is_user=False)
            return
            
        # Add the user's message to the chat
        self.add_message(recognized_text, is_user=True)
        
        if self.ai_assistant:
            # Check for special navigation commands before processing with AI
            navigation_command = self._check_for_navigation_command(recognized_text)
            if navigation_command:
                self._handle_navigation_command(navigation_command, recognized_text)
            else:
                # Process with AI
                self.ai_assistant.process_text_input(recognized_text)
                self._process_ai_response()
        else:
            # Fallback if no AI assistant
            self.add_message("AI Assistant module is not available. Please check if dependencies are installed.", is_user=False)
            
    def send_text_message(self, instance):
        """Send a text message from the input field"""
        # Get text and clear input field
        text = self.text_input.text.strip()
        self.text_input.text = ''
        
        if not text:
            return
        
        # Add message to chat
        self.add_message(text, is_user=True)
        
        if self.ai_assistant:
            # Check for special navigation commands before processing with AI
            navigation_command = self._check_for_navigation_command(text)
            if navigation_command:
                self._handle_navigation_command(navigation_command, text)
            else:
                # Process with AI
                self.ai_assistant.process_text_input(text)
                self._process_ai_response()
        else:
            # Fallback if no AI assistant
            self.add_message("AI Assistant module is not available. Please check if dependencies are installed.", is_user=False)
    
    def _on_reminder_event_change(self, instance, value):
        """Handle changes to the create_reminder_event property"""
        if not value:
            return
            
        print(f"Reminder event triggered: {value}")
        
        try:
            # Parse the reminder data
            import json
            reminder_data = json.loads(value)
            
            # Reset the event to prevent duplicate reminders
            instance.create_reminder_event = ''
            
            # Create the reminder
            self.add_message("I'm creating a medication reminder for you now...", is_user=False)
            self._create_reminder_from_ai(reminder_data)
            
        except Exception as e:
            print(f"Error processing reminder event: {e}")
            import traceback
            traceback.print_exc()
            self.add_message(f"I couldn't create the reminder: {e}", is_user=False)
    
    def _check_for_navigation_command(self, text):
        """Check if the user is requesting to navigate to a specific screen"""
        text = text.lower()
        
        # Check for navigation to reminders screen
        if any(phrase in text for phrase in [
            'go to reminder', 'go to reminders', 'show reminder', 'show reminders',
            'open reminder', 'open reminders', 'view reminder', 'view reminders',
            'take me to reminder', 'take me to reminders', 'navigate to reminder', 'navigate to reminders'
        ]):
            return 'reminder'
        
        # Check for navigation to home screen
        if any(phrase in text for phrase in [
            'go to home', 'go home', 'show home', 'open home', 'view home',
            'take me to home', 'navigate to home', 'return to home', 'back to home'
        ]):
            return 'home'
        
        return None
    
    def _handle_navigation_command(self, screen_name, original_text):
        """Handle a navigation command to a specific screen"""
        app = App.get_running_app()
        
        # Check if the requested screen exists in the screen manager
        if screen_name in app.root.screen_names:
            # Add a confirmation message
            self.add_message(f"Navigating to {screen_name.title()} screen...", is_user=False)
            
            # Navigate to the requested screen
            app.root.current = screen_name
        else:
            # If screen doesn't exist, process the text normally with AI
            if self.ai_assistant:
                self.ai_assistant.process_text_input(original_text)
                self._process_ai_response()
    
    def _process_ai_response(self):
        """Process the AI response and add it to the chat"""
        if not self.ai_assistant:
            return
        
        self.is_processing = True
        self.status_label.text = "AI is thinking..."
        
        # Check for AI response every 0.5 seconds
        def check_response(dt):
            if not self.ai_assistant.is_processing:
                # AI has responded
                self.add_message(self.ai_assistant.response_text, is_user=False)
                self.status_label.text = ''
                self.is_processing = False
                
                # Check if AI wants to create a reminder
                self._check_for_reminder_creation()
                
                return False  # Stop checking
            return True  # Keep checking
        
        # Start checking for response
        Clock.schedule_interval(check_response, 0.5)
        
    def _check_for_reminder_creation(self):
        """Check if the AI assistant wants to create a reminder"""
        # Make sure the AI assistant has the create_reminder_event property
        if not hasattr(self.ai_assistant, 'create_reminder_event'):
            print("AI assistant does not have create_reminder_event property")
            return
            
        # Check if there's a reminder event
        reminder_event = self.ai_assistant.create_reminder_event
        if not reminder_event:
            return
            
        print(f"Detected reminder event: {reminder_event}")
            
        try:
            # Parse the reminder data
            import json
            reminder_data = json.loads(reminder_event)
            print(f"Parsed reminder data: {reminder_data}")
            
            # Reset the event to prevent duplicate reminders
            self.ai_assistant.create_reminder_event = ''
            
            # Create the reminder
            self.add_message("I'm creating a reminder for you now...", is_user=False)
            self._create_reminder_from_ai(reminder_data)
            
        except Exception as e:
            print(f"Error processing reminder creation: {e}")
            self.add_message(f"There was a problem creating your reminder: {e}", is_user=False)
    
    def _create_reminder_from_ai(self, reminder_data):
        """Create a reminder using data extracted by the AI"""
        print(f"Creating reminder with data: {reminder_data}")
        
        # Check if we have a medication reminder manager available
        app = App.get_running_app()
        reminder_screen = None
        
        # First check if reminder screen exists in the screen manager
        if 'reminder' in app.root.screen_names:
            reminder_screen = app.root.get_screen('reminder')
            print("Found existing reminder screen")
        else:
            # Create and add the reminder screen if it doesn't exist
            print("Creating new reminder screen")
            reminder_screen = ReminderScreen(name='reminder')
            app.root.add_widget(reminder_screen)
        
        # Direct access to reminder manager for testing
        from medication_reminder import MedicationReminder
        if not hasattr(reminder_screen, 'reminder_manager') or not reminder_screen.reminder_manager:
            print("Reminder screen doesn't have a working reminder manager, creating one directly")
            try:
                # Try to create a reminder manager directly
                reminder_manager = MedicationReminder()
                reminder_screen.reminder_manager = reminder_manager
            except Exception as import_e:
                print(f"Failed to create MedicationReminder: {import_e}")
                self.add_message("I'm sorry, I couldn't create a reminder because the reminder system is not available.", is_user=False)
                return
            
        print(f"Reminder manager status: {reminder_screen.reminder_manager}")
        
        # Extract reminder data
        medication_name = reminder_data.get('medication')
        dosage = reminder_data.get('dosage')
        frequency = reminder_data.get('frequency')
        duration = reminder_data.get('duration')
        
        print(f"Extracted data: med={medication_name}, dosage={dosage}, freq={frequency}, duration={duration}")
        
        # Check required fields
        if not medication_name or not dosage or not frequency:
            self.add_message("I couldn't create the reminder because some required information is missing.", is_user=False)
            return
        
        # Add the reminder
        try:
            # Explicitly call the add_reminder method with proper arguments
            print("Calling add_reminder method")
            
            reminder_id = reminder_screen.reminder_manager.add_reminder(
                medication_name=medication_name,
                dosage=dosage,
                frequency=frequency,
                duration=duration,
                notes="Created by AI assistant"
            )
            
            print(f"Reminder created with ID: {reminder_id}")
            
            # Confirm success and suggest viewing reminder
            self.add_message("I've successfully created your medication reminder! Would you like to view it now in the Reminders section?", is_user=False)
            
            # Ask if they want to go to the reminder screen
            self.add_message("Say 'show reminders' if you want to see your new reminder.", is_user=False)
            
        except Exception as e:
            print(f"Error adding reminder: {e}")
            import traceback
            traceback.print_exc()
            self.add_message(f"I had trouble creating your reminder: {str(e)}. You can try adding it manually from the Reminders section.", is_user=False)

    def update_theme(self, *args):
        """Override to update specific UI elements for this screen"""
        # First call parent's update_theme to handle basic elements
        super(VoiceScreen, self).update_theme(*args)

        # Update colors based on theme
        colors = self.theme_manager.get_colors()
        is_dark = self.theme_manager.is_dark_mode

        # Update title and subtitle colors
        self.title_label.color = colors.get('primary', (0.2, 0.4, 0.8, 1))
        self.subtitle_label.color = colors['text_secondary'] if 'text_secondary' in colors else (0.5, 0.5, 0.5, 1)

        # Update status label
        self.status_label.color = colors['text_secondary'] if 'text_secondary' in colors else (0.5, 0.5, 0.5, 1)

        # Update send button colors
        self.send_btn.bg_color = self.theme_manager.get_accent_color()
        self.send_btn.color = (1, 1, 1, 1)  # Keep text white for contrast

        # Update text input colors for dark/light theme
        self.text_input.background_color = colors['input_bg']
        self.text_input.foreground_color = colors['text']
        self.text_input.cursor_color = colors['primary']

        # Update chat bubbles if any exist
        for child in self.chat_layout.children:
            if isinstance(child, ChatBubble) and hasattr(child, 'update_theme'):
                child.update_theme(is_dark)
            elif isinstance(child, BoxLayout):
                # This may be a message container
                for message_part in child.children:
                    if isinstance(message_part, Label):
                        message_part.color = colors['text']

    def add_message(self, text, is_user=True):
        """Add a message bubble to the chat"""
        bubble = ChatBubble(text, is_user=is_user)
        self.chat_layout.add_widget(bubble)
        self._scroll_to_bottom()

# Settings Screen - Hides the bar
class SettingsScreen(BaseScreen):
    def __init__(self, **kwargs):
        super(SettingsScreen, self).__init__(auto_update_theme=False, **kwargs)
        self.language_manager = LanguageManager()
    
        # Create a custom back button at the top left corner
        self.back_button.size = (dp(60), dp(60))  # Updated to match standard size
        self.back_button.font_size = dp(24)
        self.back_button.pos_hint = {'x': 0, 'top': 1}
        self.back_button.background_color = (0.8, 0.8, 0.8, 1)  # Grey color
    
        self.build_ui()
        # Now that all UI elements are created, we can call update_theme
        self.update_theme()
    
    def build_ui(self):
        """Build the settings screen UI"""
        self.main_layout.clear_widgets()
    
        # Add back button (in case it was removed)
        self.main_layout.add_widget(self.back_button)
    
        main_vbox = BoxLayout(orientation='vertical', size_hint=(1, 1))
    
        # Top bar with title and logout button
        top_bar = BoxLayout(
            orientation='horizontal',
            size_hint=(1, None),
            height=dp(60),
            padding=[dp(60), 0, dp(0), 0]  # Left padding to avoid overlapping with back button
        )
    
        # Add centered title
        title = Label(
            text=tr('settings'),
            font_size=dp(22),
            bold=True,
            color=(0.2, 0.2, 0.2, 1),  # Will be updated by theme
            halign='center',
            valign='middle',
            size_hint=(1, 1)
        )
        title.bind(size=title.setter('text_size'))
        self.title_label = title
    
        # Add logout button (right aligned)
        logout_btn = Button(
            text=tr('logout'),
            size_hint=(None, None),
            size=(dp(80), dp(50)),
            pos_hint={'center_y': 0.5, 'right': 1},
            background_normal='',
            background_color=(0.92, 0.92, 0.92, 1),  # Light grey color to match back button
            color=(0.2, 0.2, 0.2, 1),  # Dark text for better contrast
            font_size=dp(14)
        )
        logout_btn.bind(on_release=self.logout)
        self.logout_btn = logout_btn
    
        top_bar.add_widget(title)
        top_bar.add_widget(logout_btn)
        main_vbox.add_widget(top_bar)
    
        # Add some spacing
        main_vbox.add_widget(Widget(size_hint_y=None, height=dp(20)))
    
        # Settings content
        settings_stack = BoxLayout(
            orientation='vertical',
            size_hint=(None, None),
            width=dp(320),
            height=dp(300),
            pos_hint={'center_x': 0.5},
            spacing=dp(18)
        )
    
        # All settings with switches
        settings = [
            {'name': tr('notifications'), 'active': True},
            {'name': tr('dark_mode'), 'active': self.theme_manager.is_dark_mode},
            {'name': tr('sound'), 'active': True},
            {'name': tr('vibration'), 'active': True}
        ]
    
        self.setting_labels = []
        for setting in settings:
            row = BoxLayout(
                orientation='horizontal',
                size_hint=(1, None),
                height=dp(44),
                padding=[0, 0, 0, 0]
            )
            
            label = Label(
                text=setting['name'],
                font_size=dp(18),
                halign='left',
                valign='middle',
                size_hint=(0.7, 1)
            )
            label.bind(size=label.setter('text_size'))
            self.setting_labels.append(label)
            
            switch = Switch(
                active=setting['active'],
                size_hint=(0.3, 1)
            )
            
            # Bind dark mode switch to theme toggle
            if setting['name'] == tr('dark_mode'):
                switch.bind(active=self.toggle_dark_mode)
                self.dark_mode_switch = switch
            
            row.add_widget(label)
            row.add_widget(switch)
            settings_stack.add_widget(row)
    
        # Language selection row
        lang_row = BoxLayout(
            orientation='horizontal',
            size_hint=(1, None),
            height=dp(44)
        )
    
        lang_label = Label(
            text=tr('language'),
            font_size=dp(18),
            halign='left',
            valign='middle',
            size_hint=(0.7, 1)
        )
        lang_label.bind(size=lang_label.setter('text_size'))
        self.setting_labels.append(lang_label)
    
        # Map language codes to display names
        lang_names = {
            'en': 'English',
            'ro': 'Română',
            'ru': 'Русский'
        }
    
        # Get current language display name
        current_lang = self.language_manager.current_language
        current_lang_name = lang_names.get(current_lang, 'English')
    
        self.language_spinner = Spinner(
            text=current_lang_name,
            values=[lang_names[code] for code in LANGUAGES],
            size_hint=(0.3, 1),
            background_normal='',
            background_color=(0.95, 0.95, 0.95, 1),  # Will be updated by theme
            color=(0.2, 0.2, 0.2, 1),  # Will be updated by theme
            font_size=dp(16)
        )
        self.language_spinner.bind(text=self.on_language_change)
    
        lang_row.add_widget(lang_label)
        lang_row.add_widget(self.language_spinner)
        settings_stack.add_widget(lang_row)
    
        main_vbox.add_widget(settings_stack)
        main_vbox.add_widget(Widget())  # Spacer at the bottom
    
        self.main_layout.add_widget(main_vbox)
    
    def update_theme(self, *args):
        """Override BaseScreen's update_theme to handle specific UI elements"""
        # Call parent method to handle basic elements
        super(SettingsScreen, self).update_theme(*args)
        
        # Get theme colors
        colors = self.theme_manager.get_colors()
        is_dark = self.theme_manager.is_dark_mode
        
        # Update all setting labels with appropriate colors
        if hasattr(self, 'setting_labels'):
            for label in self.setting_labels:
                label.color = colors['text']
            
        # Update title with proper color
        if hasattr(self, 'title_label'):
            self.title_label.color = colors['text']
            
        # Update logout button with grey colors, matching back button
        if hasattr(self, 'logout_btn'):
            if is_dark:
                self.logout_btn.background_color = (0.2, 0.2, 0.22, 1)  # Darker grey for dark mode
                self.logout_btn.color = (0.9, 0.9, 0.9, 1)  # Light text for dark mode
            else:
                self.logout_btn.background_color = (0.92, 0.92, 0.92, 1)  # Light grey for light mode
                self.logout_btn.color = (0.2, 0.2, 0.2, 1)  # Dark text for light mode
                
        # Update language spinner with theme colors
        if hasattr(self, 'language_spinner'):
            if is_dark:
                self.language_spinner.background_color = colors['input_bg']
                self.language_spinner.color = colors['text']
            else:
                self.language_spinner.background_color = colors['input_bg']
                self.language_spinner.color = colors['text']
        
        # Make sure switches are correctly updated if they exist
        if hasattr(self, 'dark_mode_switch'):
            # No need to change the switch appearance, just ensure it reflects the current state
            self.dark_mode_switch.active = is_dark
            
        # Update any other UI elements
        for child in self.walk(restrict=True):
            # Update all Labels
            if isinstance(child, Label) and child not in self.setting_labels and child != self.title_label:
                child.color = colors['text']
                
            # Update all standard buttons
            elif isinstance(child, Button) and child != self.logout_btn:
                if not any(isinstance(child, cls) for cls in [RoundedButton, IconButton]):
                    child.background_color = colors['button_bg']
                    child.color = colors['button_text']

    def on_language_change(self, spinner, text):
        # Map visible text to language code
        lang_map = {'English': 'en', 'Română': 'ro', 'Русский': 'ru'}
        lang = lang_map.get(text, 'en')
        CURRENT_LANGUAGE['lang'] = lang
        self.build_ui()
        # Refresh all screens
        app = App.get_running_app()
        for screen in app.screen_manager.screens:
            if hasattr(screen, 'build_ui'):
                screen.build_ui()
            if hasattr(screen, 'update_theme'):
                screen.update_theme()

    def toggle_dark_mode(self, switch, value):
        self.theme_manager.set_dark_mode(value)
        self.update_theme()

    def logout(self, instance):
        app = App.get_running_app()
        app.current_user = None
        self.manager.transition = SlideTransition(direction='right')
        self.manager.current = 'login'

    def _update_language_ai_assistant(self, *args):
        try:
            if hasattr(self, 'ai_assistant_label'):
                self.ai_assistant_label.text = tr('ask_ai_assistant')
            if hasattr(self, 'ai_description_label'):
                self.ai_description_label.text = tr('ai_assistant_description')
            if hasattr(self, 'back_to_home_btn'): 
                self.back_to_home_btn.text = tr('back_to_home')
            if hasattr(self, 'medication_query_input'):
                self.medication_query_input.hint_text = tr('type_your_question_here')
            if hasattr(self, 'submit_query_btn'):
                self.submit_query_btn.text = tr('ask_ai')
        except Exception as e:
            print(f"Error updating language in AIAssistant: {e}")

class HomeScreen(BaseScreen):
    def __init__(self, **kwargs):
        # Pass auto_update_theme=False to prevent premature theme update
        super(HomeScreen, self).__init__(auto_update_theme=False, **kwargs)
        
        # Import RoundButton
        from round_button import RoundButton
        self.RoundButton = RoundButton  # Store for later use
        
        # Make the back button larger and positioned in the corner
        self.back_button.size = (dp(60), dp(60))
        self.back_button.font_size = dp(24)
        self.back_button.pos_hint = {'x': 0, 'top': 1}
        self.back_button.background_color = (0.8, 0.8, 0.8, 1)  # Grey color
        
        self.theme_manager = ThemeManager()
        self.messages = []
        self.load_messages()
        
        # Main layout
        self.main_layout = FloatLayout()
        self.main_layout.background_color = (0, 0, 0, 0)  # Fully transparent
        with self.main_layout.canvas.before:
            self.bg_color = Color(0.98, 0.98, 0.98, 1)
            self.bg_rect = Rectangle(pos=self.main_layout.pos, size=self.main_layout.size)
        self.main_layout.bind(pos=self._update_rect, size=self._update_rect)
        
        # Top bar
        self.top_bar = BoxLayout(
            size_hint=(1, None),
            height=dp(60),
            padding=[dp(10), dp(10)],
            pos_hint={'top': 1}
        )
        self.top_bar.background_color = (0, 0, 0, 0)  # Fully transparent
        with self.top_bar.canvas.before:
            self.top_bar_bg_color = Color(1, 1, 1, 1)
            self.top_bar_bg = Rectangle(pos=self.top_bar.pos, size=self.top_bar.size)
            self.top_bar.bind(pos=self._update_top_rect, size=self._update_top_rect)
        
        self.username_label = Label(
            text='Welcome!',
            font_size=dp(18),
            bold=True,
            color=(0.2, 0.2, 0.2, 1)
        )
        self.top_bar.add_widget(self.username_label)
        self.main_layout.add_widget(self.top_bar)
        
        # Chat feed
        self.scroll_view = ScrollView(
            size_hint=(1, None),
            height=Window.height - dp(140),  # Adjusted for nav bar
            pos_hint={'top': 1 - (self.top_bar.height / Window.height)},
            do_scroll_x=False
        )
        self.chat_layout = BoxLayout(
            orientation='vertical',
            size_hint_y=None,
            spacing=dp(10),
            padding=[dp(10), dp(10)]
        )
        self.chat_layout.background_color = (0, 0, 0, 0)  # Fully transparent
        self.chat_layout.bind(minimum_height=self.chat_layout.setter('height'))
        self.scroll_view.add_widget(self.chat_layout)
        self.main_layout.add_widget(self.scroll_view)
        
        # Floating Action Button (FAB)
        class FabButton(ButtonBehavior, BoxLayout):
            pass
            
        fab_container = FabButton(
            size_hint=(None, None),
            size=(dp(60), dp(60)),  # Increased from 50 to 60
            pos_hint={'right': 0.95, 'y': 0.14}
        )
        with fab_container.canvas.before:
            Color(0.2, 0.6, 0.9, 0.6)  # Blue color
            self.fab_bg = RoundedRectangle(
                pos=fab_container.pos,
                size=fab_container.size,
                radius=[dp(30)]  # Half of size for perfect circle
            )
        fab_container.bind(pos=self._update_fab_bg, size=self._update_fab_bg)
        
        self.fab = Label(
            text='+',
            font_size=dp(32),  # Increased from 24 to 32
            bold=True,
            color=(1, 1, 1, 0.8)  # White text
        )
        fab_container.add_widget(self.fab)
        fab_container.bind(on_release=self.show_post_popup)
        self.main_layout.add_widget(fab_container)
        
        # Create navigation bar container
        self.nav_container = FloatLayout(size_hint=(1, None), height=dp(80))
        self.nav_container.pos_hint = {'x': 0, 'y': 0}  # Position at bottom
        self.nav_container.background_color = (0, 0, 0, 0)  # Fully transparent
        
        # Create rounded navigation bar background with theme-based colors
        with self.nav_container.canvas.before:
            self.nav_shadow_color = Color(0.7, 0.7, 0.7, 0.2)
            RoundedRectangle(
                pos=(self.nav_container.x + dp(4), self.nav_container.y - dp(4)),
                size=(self.nav_container.width, self.nav_container.height),
                radius=[(dp(20), dp(20), 0, 0)]
            )
            
            self.nav_shadow_color2 = Color(0.75, 0.75, 0.75, 0.5)
            RoundedRectangle(
                pos=(self.nav_container.x + dp(2), self.nav_container.y - dp(2)),
                size=(self.nav_container.width, self.nav_container.height),
                radius=[(dp(20), dp(20), 0, 0)]
            )
            
            self.nav_bg_color = Color(0.92, 0.92, 0.92, 1)
            self.nav_rect = RoundedRectangle(
                pos=(self.nav_container.x, self.nav_container.y),
                size=(self.nav_container.width, self.nav_container.height),
                radius=[(dp(20), dp(20), 0, 0)]
            )
            self.nav_container.bind(pos=self._update_nav_rect, size=self._update_nav_rect)
        
        # Create navigation bar
        nav_bar = BoxLayout(
            size_hint=(0.95, 0.9),
            pos_hint={'center_x': 0.5, 'center_y': 0.5},
            spacing=dp(10),
            padding=[dp(10), dp(5), dp(10), dp(5)]
        )
        nav_bar.background_color = (0, 0, 0, 0)  # Fully transparent
        
        # Create regular navigation buttons with icons
        buttons = [
            {'icon': 'home', 'text': 'Home', 'screen': 'home'},
            {'icon': 'reminder', 'text': 'Reminder', 'screen': 'reminder'},
            {'icon': 'mediscan', 'text': 'MediScan', 'screen': 'mediscan'},
            {'icon': 'voice', 'text': 'Voice', 'screen': 'voice'},
            {'icon': 'settings', 'text': 'Settings', 'screen': 'settings'}
        ]
        
        # Add all buttons to the navigation bar
        for btn in buttons:
            button = IconButton(
                icon_type=btn['icon'],
                text=btn['text']
            )
            button.bind(on_release=lambda x, screen=btn['screen']: self.navigate_to(screen))
            nav_bar.add_widget(button)
        
        # Add navigation bar to container
        self.nav_container.add_widget(nav_bar)
        
        # Add navigation container to main layout
        self.main_layout.add_widget(self.nav_container)
        
        self.add_widget(self.main_layout)
        
        # Now that all widgets are initialized, update the theme
        self.update_theme()
        
        # Refresh chat every 5 seconds
        Clock.schedule_interval(self.refresh_chat, 5)

    def show_post_popup(self, instance):
        content = BoxLayout(orientation='vertical', padding=dp(20), spacing=dp(10))
        
        # Message input
        self.message_input = TextInput(
            multiline=True,
            size_hint=(1, None),
            height=dp(100),
            hint_text='Share your thoughts...',
            padding=[dp(10), dp(10)]
        )
        content.add_widget(self.message_input)
        
        # Image preview
        self.image_preview = Image(
            size_hint=(1, None),
            height=dp(0),
            allow_stretch=True,
            keep_ratio=True
        )
        content.add_widget(self.image_preview)
        
        # Buttons layout
        buttons_layout = BoxLayout(
            size_hint=(1, None),
            height=dp(50),
            spacing=dp(10)
        )
        
        # Image button
        image_btn = Button(
            text='+',
            size_hint=(None, None),
            size=(dp(40), dp(40)),
            background_color=(0.3, 0.6, 1, 1),
            background_normal='',
            font_size=dp(24),
            bold=True
        )
        image_btn.bind(on_release=self.show_image_chooser)
        
        # Post button
        post_btn = Button(
            text='Post',
            size_hint=(0.8, 1),
            background_normal='',
            background_color=(0.2, 0.8, 0.2, 1)
        )
        post_btn.bind(on_release=self.send_message)
        
        buttons_layout.add_widget(image_btn)
        buttons_layout.add_widget(post_btn)
        content.add_widget(buttons_layout)
        
        # Create popup
        self.post_popup = Popup(
            title='Create Post',
            content=content,
            size_hint=(0.9, 0.6),
            pos_hint={'center_x': 0.5, 'center_y': 0.5}
        )
        self.post_popup.open()

    def show_image_chooser(self, instance):
        content = BoxLayout(orientation='vertical')
        
        # Create file chooser
        file_chooser = FileChooserListView(
            path='/',  # Start from root directory
            filters=['*.png', '*.jpg', '*.jpeg']
        )
        
        # Create buttons
        buttons = BoxLayout(
            size_hint_y=None,
            height=dp(50),
            spacing=dp(10)
        )
        
        select_btn = Button(
            text='Select',
            size_hint_x=0.5
        )
        
        cancel_btn = Button(
            text='Cancel',
            size_hint_x=0.5
        )
        
        buttons.add_widget(select_btn)
        buttons.add_widget(cancel_btn)
        
        content.add_widget(file_chooser)
        content.add_widget(buttons)
        
        # Create popup
        popup = Popup(
            title='Choose Image',
            content=content,
            size_hint=(0.9, 0.9)
        )
        
        def select_image(instance):
            if file_chooser.selection:
                selected_file = file_chooser.selection[0]
                # Store the selected image path
                self.selected_image = selected_file
                # Update preview
                self.image_preview.source = selected_file
                self.image_preview.height = dp(100)
            popup.dismiss()
        
        def cancel(instance):
            popup.dismiss()
        
        select_btn.bind(on_release=select_image)
        cancel_btn.bind(on_release=cancel)
        
        popup.open()

    def send_message(self, instance):
        message_text = self.message_input.text.strip()
        if not message_text and not hasattr(self, 'selected_image'):
            return
        
        username = App.get_running_app().current_user
        if not username:
            return
        
        message_data = {
            'id': str(uuid.uuid4()),  # Add unique ID for each message
            'username': username,
            'message': message_text,
            'image': getattr(self, 'selected_image', None),
            'timestamp': datetime.now().strftime("%H:%M")
        }
        
        self.messages.insert(0, message_data)  # Insert at beginning for newest first
        self.save_messages()
        self.add_message_to_chat(message_data)
        
        self.message_input.text = ''
        if hasattr(self, 'selected_image'):
            delattr(self, 'selected_image')
            self.image_preview.source = ''
            self.image_preview.height = dp(0)
        
        self.post_popup.dismiss()

    def navigate_to(self, screen_type):
        print(f"Navigating to {screen_type} screen")
        app = App.get_running_app()
        
        # Check if screen exists first
        if screen_type == 'home':
            # Already on home screen, no need to navigate
            return
        elif screen_type not in app.root.screen_names:
            # Create the screen if it doesn't exist
            if screen_type == 'reminder':
                app.root.add_widget(ReminderScreen(name='reminder'))
            elif screen_type == 'mediscan':
                app.root.add_widget(MediScanScreen(name='mediscan'))
            elif screen_type == 'voice':
                app.root.add_widget(VoiceScreen(name='voice'))
            elif screen_type == 'settings':
                app.root.add_widget(SettingsScreen(name='settings'))
        
        # Navigate to the screen
        app.root.current = screen_type

    def _update_rect(self, instance, value):
        self.bg_rect.pos = instance.pos
        self.bg_rect.size = instance.size

    def _update_top_rect(self, instance, value):
        self.top_bar_bg.pos = instance.pos
        self.top_bar_bg.size = instance.size

    def _update_nav_rect(self, instance, value):
        self.nav_rect.pos = (instance.x, instance.y)
        self.nav_rect.size = (instance.width, instance.height)

    def _update_fab_shadow(self, instance, value):
        self.fab_bg.pos = instance.pos
        self.fab_bg.size = instance.size

    def update_theme(self, *args):
        from kivy.core.window import Window
        is_dark = self.theme_manager.is_dark_mode
        Window.clearcolor = (0.12, 0.12, 0.14, 1) if is_dark else (0.98, 0.98, 0.98, 1)
        print("Theme updated:", "dark" if is_dark else "light")

        # Redraw main background
        self.main_layout.canvas.before.clear()
        with self.main_layout.canvas.before:
            self.bg_color = Color(0.12, 0.12, 0.14, 1) if is_dark else Color(0.98, 0.98, 0.98, 1)
            self.bg_rect = Rectangle(pos=self.main_layout.pos, size=self.main_layout.size)
        self.main_layout.bind(pos=self._update_rect, size=self._update_rect)

        # Redraw top bar
        self.top_bar.canvas.before.clear()
        with self.top_bar.canvas.before:
            self.top_bar_bg_color = Color(0.15, 0.15, 0.17, 1) if is_dark else Color(1, 1, 1, 1)
            self.top_bar_bg = Rectangle(pos=self.top_bar.pos, size=self.top_bar.size)
        self.top_bar.bind(pos=self._update_top_rect, size=self._update_top_rect)
        self.username_label.color = (0.9, 0.9, 0.9, 1) if is_dark else (0.2, 0.2, 0.2, 1)

        # Redraw nav bar
        self.nav_container.canvas.before.clear()
        with self.nav_container.canvas.before:
            self.nav_shadow_color = Color(0.1, 0.1, 0.1, 0.4) if is_dark else Color(0.7, 0.7, 0.7, 0.2)
            RoundedRectangle(
                pos=(self.nav_container.x + dp(4), self.nav_container.y - dp(4)),
                size=(self.nav_container.width, self.nav_container.height),
                radius=[(dp(20), dp(20), 0, 0)]
            )
            self.nav_shadow_color2 = Color(0.1, 0.1, 0.1, 0.6) if is_dark else Color(0.75, 0.75, 0.75, 0.5)
            RoundedRectangle(
                pos=(self.nav_container.x + dp(2), self.nav_container.y - dp(2)),
                size=(self.nav_container.width, self.nav_container.height),
                radius=[(dp(20), dp(20), 0, 0)]
            )
            self.nav_bg_color = Color(0.2, 0.2, 0.2, 1) if is_dark else Color(0.92, 0.92, 0.92, 1)
            self.nav_rect = RoundedRectangle(
                pos=(self.nav_container.x, self.nav_container.y),
                size=(self.nav_container.width, self.nav_container.height),
                radius=[(dp(20), dp(20), 0, 0)]
            )
        self.nav_container.bind(pos=self._update_nav_rect, size=self._update_nav_rect)

        

        # Update post popup colors if it exists
        if hasattr(self, 'post_popup') and self.post_popup:
            if is_dark:
                self.message_input.foreground_color = (0.9, 0.9, 0.9, 1)
                self.message_input.hint_text_color = (0.6, 0.6, 0.6, 1)
                self.message_input.background_color = (0.15, 0.15, 0.15, 1)
            else:
                self.message_input.foreground_color = (0.2, 0.2, 0.2, 1)
                self.message_input.hint_text_color = (0.5, 0.5, 0.5, 1)
                self.message_input.background_color = (0.95, 0.95, 0.95, 1)
            self.image_button.background_color = (0.3, 0.5, 0.9, 1)
            self.post_button.background_color = (0.2, 0.8, 0.2, 1)

        # Update chat messages
        for child in self.chat_layout.children:
            if isinstance(child, ChatMessage):
                child.update_theme()

        # Force redraw
        self.canvas.ask_update()

    def load_messages(self):
        try:
            if os.path.exists('chat_messages.json'):
                with open('chat_messages.json', 'r') as f:
                    self.messages = json.load(f)
        except Exception as e:
            print(f"Error loading messages: {e}")
            self.messages = []

    def save_messages(self):
        try:
            with open('chat_messages.json', 'w') as f:
                json.dump(self.messages, f)
        except Exception as e:
            print(f"Error saving messages: {e}")

    def add_message_to_chat(self, message_data, scroll_to_bottom=False):
        """Add a new message to the chat"""
        message = ChatMessage(
            username=message_data['username'],
            message=message_data['message'],
            image_path=message_data.get('image'),  # Use correct key
            timestamp=message_data.get('timestamp'),
            message_id=message_data.get('id')      # Use correct key
        )
        self.chat_layout.add_widget(message)
        self.save_messages()
        if scroll_to_bottom:
            Clock.schedule_once(self._scroll_to_bottom)

    def refresh_chat(self, dt):
        self.chat_layout.clear_widgets()
        for message in self.messages:
            self.add_message_to_chat(message, scroll_to_bottom=False)

    def update_username(self, username):
        self.username_label.text = f"Welcome, {username}!"

    def _update_input_rect(self, instance, value):
        self.input_bg.pos = instance.pos
        self.input_bg.size = instance.size

    def _scroll_to_bottom(self, *args):
        if hasattr(self, 'scroll_view') and hasattr(self, 'chat_layout'):
            self.scroll_view.scroll_y = 0

    def _update_fab_bg(self, instance, value):
        self.fab_bg.pos = instance.pos
        self.fab_bg.size = instance.size

class LoginScreen(Screen):
    def __init__(self, **kwargs):
        super(LoginScreen, self).__init__(**kwargs)
        self.theme_manager = ThemeManager()
        self.user_db = UserDatabase()  # Initialize the database
        
        # Main layout
        self.main_layout = FloatLayout()
        
        # Set screenshot as background image
        self.bg_image = Image(
            source='icons/Screenshot 2025-05-21 at 17.58.57.png',
            allow_stretch=True,
            keep_ratio=False,
            size_hint=(1, 1),
            pos_hint={'x': 0, 'y': 0}
        )
        self.main_layout.add_widget(self.bg_image)
        
        # Create a vertical box layout for the form
        form_layout = BoxLayout(
            orientation='vertical',
            size_hint=(0.6, 0.6),
            pos_hint={'center_x': 0.5, 'center_y': 0.5},
            spacing=dp(10),
            padding=[0, dp(20)]
        )
        
        # Username input
        self.username_input = TextInput(
            hint_text=tr('username'),
            multiline=False,
            size_hint=(1, None),
            height=dp(50),
            padding=[dp(10), dp(10)],
            font_size=dp(16),
            background_color=(1, 1, 1, 0.8)
        )
        
        # Email input
        self.email_input = TextInput(
            hint_text=tr('email'),
            multiline=False,
            size_hint=(1, None),
            height=dp(50),
            padding=[dp(10), dp(10)],
            font_size=dp(16),
            background_color=(1, 1, 1, 0.8)
        )
        
        # Password input with show/hide functionality
        password_layout = BoxLayout(
            orientation='horizontal',
            size_hint=(1, None),
            height=dp(50),
            spacing=dp(10)
        )
        
        self.password_input = TextInput(
            hint_text=tr('password'),
            password=True,
            multiline=False,
            size_hint=(0.85, 1),
            padding=[dp(10), dp(10)],
            font_size=dp(16),
            background_color=(1, 1, 1, 0.8)
        )
        
        self.show_password_btn = Button(
            text='👁',
            size_hint=(0.15, 1),
            background_normal='',
            background_color=(0.9, 0.9, 0.9, 0.8)
        )
        self.show_password_btn.bind(on_press=self.toggle_password_visibility)
        
        password_layout.add_widget(self.password_input)
        password_layout.add_widget(self.show_password_btn)
        
        # Error label
        self.error_label = Label(
            text='',
            color=(1, 0, 0, 1),
            size_hint=(1, None),
            height=dp(30),
            font_size=dp(14)
        )
        
        # Login button
        self.login_btn = RoundedButton(
            text=tr('login'),
            size_hint=(1, None),
            height=dp(50),
            bg_color=(0.4, 0.7, 1, 0.9)
        )
        self.login_btn.bind(on_release=self.login)
        
        # Register button
        self.register_btn = RoundedButton(
            text=tr('sign_up'),
            size_hint=(1, None),
            height=dp(50),
            bg_color=(1, 1, 1, 1),  # Pure white (#FFFFFF)
            text_color=(0x44/255, 0x61/255, 0xcc/255, 1)  # Light blue text color (#4461cc)
        )
        self.register_btn.bind(on_release=self.show_signup)
        
        # Add widgets to form layout
        form_layout.add_widget(self.username_input)
        form_layout.add_widget(self.email_input)
        form_layout.add_widget(password_layout)
        form_layout.add_widget(self.error_label)
        form_layout.add_widget(self.login_btn)
        form_layout.add_widget(self.register_btn)
        
        # Add form layout to main layout
        self.main_layout.add_widget(form_layout)
        
        self.add_widget(self.main_layout)
        
        # Bind background image size to layout size
        self.main_layout.bind(size=self._update_bg_image, pos=self._update_bg_image)

    def _update_bg_image(self, *args):
        self.bg_image.size = self.main_layout.size
        self.bg_image.pos = self.main_layout.pos

    def update_theme(self, *args):
        pass  # No background color, just the image

    def toggle_password_visibility(self, instance):
        self.password_input.password = not self.password_input.password

    def login(self, instance):
        username = self.username_input.text.strip()
        password = self.password_input.text.strip()
        
        if not username or not password:
            self.error_label.text = tr('please_fill_all_fields')
            return
            
        success, message = self.user_db.verify_user(username, password)
        
        if not success:
            self.error_label.text = message
            return
            
        # Only proceed if authentication was successful
        app = App.get_running_app()
        app.on_login_success(username)
        self.manager.current = 'home'
        self.error_label.text = ''
        # Clear the input fields
        self.username_input.text = ''
        self.password_input.text = ''

    def show_signup(self, instance):
        self.manager.current = 'signup'
        self.error_label.text = ''

class SignupScreen(Screen):
    def __init__(self, **kwargs):
        super(SignupScreen, self).__init__(**kwargs)
        self.theme_manager = ThemeManager()
        self.user_db = UserDatabase()  # Initialize the database
        
        # Main layout
        self.main_layout = FloatLayout()
        
        # Set screenshot as background image
        self.bg_image = Image(
            source='icons/Screenshot 2025-05-21 at 17.58.57.png',
            allow_stretch=True,
            keep_ratio=False,
            size_hint=(1, 1),
            pos_hint={'x': 0, 'y': 0}
        )
        self.main_layout.add_widget(self.bg_image)
        
        # Create a vertical box layout for the form
        form_layout = BoxLayout(
            orientation='vertical',
            size_hint=(0.6, 0.6),  # Changed from 0.8 to 0.6 to match login page
            pos_hint={'center_x': 0.5, 'center_y': 0.5},
            spacing=dp(10),
            padding=[0, dp(20)]
        )
        
        # Username input
        self.username_input = TextInput(
            hint_text=tr('username'),
            multiline=False,
            size_hint=(1, None),
            height=dp(50),
            padding=[dp(10), dp(10)],
            font_size=dp(16),
            background_color=(1, 1, 1, 0.8)
        )
        
        # Email input
        self.email_input = TextInput(
            hint_text=tr('email'),
            multiline=False,
            size_hint=(1, None),
            height=dp(50),
            padding=[dp(10), dp(10)],
            font_size=dp(16),
            background_color=(1, 1, 1, 0.8)
        )
        
        # Password input with show/hide functionality
        password_layout = BoxLayout(
            orientation='horizontal',
            size_hint=(1, None),
            height=dp(50),
            spacing=dp(10)
        )
        
        self.password_input = TextInput(
            hint_text=tr('password'),
            password=True,
            multiline=False,
            size_hint=(0.85, 1),
            padding=[dp(10), dp(10)],
            font_size=dp(16),
            background_color=(1, 1, 1, 0.8)
        )
        
        self.show_password_btn = Button(
            text='👁',
            size_hint=(0.15, 1),
            background_normal='',
            background_color=(0.9, 0.9, 0.9, 0.8)
        )
        self.show_password_btn.bind(on_press=self.toggle_password_visibility)
        
        password_layout.add_widget(self.password_input)
        password_layout.add_widget(self.show_password_btn)
        
        # Error label
        self.error_label = Label(
            text='',
            color=(1, 0, 0, 1),
            size_hint=(1, None),
            height=dp(30),
            font_size=dp(14)
        )
        
        # Register button
        self.register_btn = RoundedButton(
            text=tr('sign_up'),
            size_hint=(1, None),
            height=dp(50),
            bg_color=(0.4, 0.7, 1, 0.9)
        )
        self.register_btn.bind(on_release=self.register)
        
        # Login button
        self.login_btn = RoundedButton(
            text=tr('login'),
            size_hint=(1, None),
            height=dp(50),
            bg_color=(1, 1, 1, 1),  # Pure white (#FFFFFF)
            text_color=(0x44/255, 0x61/255, 0xcc/255, 1)  # Light blue text color (#4461cc)
        )
        self.login_btn.bind(on_release=self.show_login)
        
        # Add widgets to form layout
        form_layout.add_widget(self.username_input)
        form_layout.add_widget(self.email_input)
        form_layout.add_widget(password_layout)
        form_layout.add_widget(self.error_label)
        form_layout.add_widget(self.login_btn)
        form_layout.add_widget(self.register_btn)
        
        # Add form layout to main layout
        self.main_layout.add_widget(form_layout)
        
        self.add_widget(self.main_layout)
        
        # Bind background image size to layout size
        self.main_layout.bind(size=self._update_bg_image, pos=self._update_bg_image)

    def _update_bg_image(self, *args):
        self.bg_image.size = self.main_layout.size
        self.bg_image.pos = self.main_layout.pos

    def update_theme(self, *args):
        pass  # No background color, just the image

    def toggle_password_visibility(self, instance):
        self.password_input.password = not self.password_input.password

    def register(self, instance):
        username = self.username_input.text.strip()
        password = self.password_input.text.strip()
        
        if not username or not password:
            self.error_label.text = tr('please_fill_all_fields')
            return
            
        success, message = self.user_db.add_user(username, password)
        
        if success:
            self.error_label.text = tr('registration_successful')
            # Clear the input fields
            self.username_input.text = ''
            self.password_input.text = ''
            # Go back to login screen after a short delay
            Clock.schedule_once(lambda dt: self.show_login(None), 2)
        else:
            self.error_label.text = message

    def show_login(self, instance):
        self.manager.current = 'login'
        self.error_label.text = ''

class PressableLabel(ButtonBehavior, Label):
    pass

class InitialScreen(BaseScreen):
    def __init__(self, **kwargs):
        super(InitialScreen, self).__init__(auto_update_theme=False, **kwargs)
        if hasattr(self, 'back_button') and self.back_button in self.main_layout.children:
            self.main_layout.remove_widget(self.back_button)

        logo_image = Image(
            source='icons/Logo.png',
            size_hint=(None, None),
            size=(dp(280), dp(280)),
            pos_hint={'center_x': 0.5, 'center_y': 0.6}
        )
        self.main_layout.add_widget(logo_image)

        button_layout = BoxLayout(
            orientation='vertical',
            size_hint=(None, None),
            size=(dp(200), dp(120)),
            spacing=dp(15),
            pos_hint={'center_x': 0.5, 'center_y': 0.3}
        )

        purple_color_hex = '#b06cf4'
        def hex_to_rgb(hex_color):
            hex_color = hex_color.lstrip('#')
            hlen = len(hex_color)
            return tuple(int(hex_color[i:i + hlen // 3], 16) / 255.0 for i in range(0, hlen, hlen // 3))
        purple_color = hex_to_rgb(purple_color_hex)

        self.login_btn = RoundedButton(
            text='LOG IN',
            font_size=dp(18),
            bold=True,
            size_hint=(1, None),
            height=dp(50),
            bg_color=purple_color,
            text_color=(1, 1, 1, 1)
        )
        self.login_btn.bind(on_release=self.go_to_login)
        button_layout.add_widget(self.login_btn)

        self.register_label = PressableLabel(
            text='REGISTER',
            font_size=dp(18),
            bold=True,
            size_hint=(1, None),
            height=dp(50),
            color=purple_color,
            halign='center',
            valign='middle'
        )
        self.register_label.bind(size=self.register_label.setter('text_size'))
        self.register_label.bind(on_release=self.go_to_signup)
        button_layout.add_widget(self.register_label)

        self.main_layout.add_widget(button_layout)
        self.update_theme()

    def go_to_login(self, instance):
        self.manager.current = 'login'

    def go_to_signup(self, instance):
        self.manager.current = 'register'

    def update_theme(self, *args):
        super(InitialScreen, self).update_theme(*args)
        is_dark = self.theme_manager.is_dark_mode
        purple_color_hex = '#9b44f3'
        def hex_to_rgb(hex_color):
            hex_color = hex_color.lstrip('#')
            hlen = len(hex_color)
            return tuple(int(hex_color[i:i + hlen // 3], 16) / 255.0 for i in range(0, hlen, hlen // 3))
        purple_color = hex_to_rgb(purple_color_hex)
        if hasattr(self, 'login_btn'):
            if is_dark:
                self.login_btn.bg_color = hex_to_rgb('#c08cf8')
            else:
                self.login_btn.bg_color = purple_color
            self.login_btn.color = (1, 1, 1, 1)
            if hasattr(self.login_btn, '_update_canvas'):
                self.login_btn._update_canvas()
        if hasattr(self, 'register_label'):
            if is_dark:
                self.register_label.color = hex_to_rgb('#c08cf8')
            else:
                self.register_label.color = purple_color

class ChatMessage(BoxLayout):
    def __init__(self, username, message, image_path=None, timestamp=None, message_id=None, **kwargs):
        super(ChatMessage, self).__init__(**kwargs)
        self.orientation = 'vertical'
        self.size_hint_y = None
        self.height = dp(140) if image_path else dp(80)
        self.padding = [dp(10), dp(2), dp(10), dp(0)]
        self.spacing = dp(2)
        self.message_id = message_id
        self.theme_manager = ThemeManager()
        self.image_path = image_path
        
        # Create background with shadow
        with self.canvas.before:
            self.shadow_color = Color(0, 0, 0, 0.1)
            self.shadow = RoundedRectangle(
                pos=(self.x + dp(2), self.y - dp(2)),
                size=self.size,
                radius=[dp(10)]
            )
            is_dark = self.theme_manager.is_dark_mode
            self.bg_color = Color(0.95, 0.95, 0.95, 1) if not is_dark else Color(0.2, 0.2, 0.2, 1)
            self.bg = RoundedRectangle(
                pos=self.pos,
                size=self.size,
                radius=[dp(10)]
            )

        # Main content box that will contain everything
        content_box = BoxLayout(
            orientation='vertical',
            size_hint=(1, 1),
            spacing=dp(5)
        )

        # Header with username and time
        header = BoxLayout(
            orientation='horizontal',
            size_hint_y=None,
            height=dp(30),
            padding=[dp(10), dp(5), dp(10), 0],
            spacing=dp(10)
        )
        app = App.get_running_app()
        if hasattr(app, 'current_user') and username == app.current_user:
            delete_btn = RoundButton(
                text='×',
                font_size=dp(18),
                bold=True,
                size_hint=(None, None),
                size=(dp(26), dp(26)),
                pos_hint={'center_y': 0.5},
                bg_color=(0.9, 0.3, 0.3, 1),
                fg_color=(1, 1, 1, 1)
            )
            delete_btn.bind(on_release=self.delete_message)
            header.add_widget(delete_btn)
        self.username_label = Label(
            text=username,
            size_hint_x=0.6,
            halign='center',
            valign='middle',
            color=(0.2, 0.2, 0.2, 1) if not is_dark else (0.9, 0.9, 0.9, 1),
            bold=True
        )
        self.username_label.bind(size=self.username_label.setter('text_size'))
        self.time_label = Label(
            text=self.format_timestamp(timestamp),
            size_hint_x=0.3,
            halign='right',
            valign='middle',
            color=(0.5, 0.5, 0.5, 1) if not is_dark else (0.7, 0.7, 0.7, 1)
        )
        self.time_label.bind(size=self.time_label.setter('text_size'))
        header.add_widget(self.username_label)
        header.add_widget(self.time_label)
        content_box.add_widget(header)

        # Message content
        message_box = BoxLayout(
            orientation='vertical',
            size_hint_y=None,
            height=dp(50) + (dp(60) if image_path else 0),
            padding=[dp(5), 0],
            spacing=dp(5)
        )
        self.message_label = Label(
            text=message,
            size_hint_y=None,
            height=dp(50),
            halign='left',
            valign='top',
            text_size=(Window.width * 0.8, None),
            color=(0.3, 0.3, 0.3, 1) if not is_dark else (0.9, 0.9, 0.9, 1)
        )
        self.message_label.bind(size=self.message_label.setter('text_size'))
        message_box.add_widget(self.message_label)
        if image_path:
            try:
                image = AsyncImage(
                    source=image_path,
                    size_hint=(1, None),
                    height=dp(80),
                    allow_stretch=True,
                    keep_ratio=True
                )
                image.bind(on_touch_down=self.show_full_image)
                message_box.add_widget(image)
            except Exception as e:
                print(f"Error loading image: {e}")
        content_box.add_widget(message_box)
        
        # Add the content box to the main widget
        self.add_widget(content_box)
        
        self.bind(size=self._update_rect, pos=self._update_rect)
        self.update_theme()

    def show_full_image(self, instance, touch):
        if not self.image_path:
            return False
        
        # Check if touch is within image bounds
        if not instance.collide_point(*touch.pos):
            return False
            
        # Create full-screen popup
        content = BoxLayout(orientation='vertical')
        
        # Full-screen image
        full_image = Image(
            source=self.image_path,
            allow_stretch=True,
            keep_ratio=True
        )
        
        # Close button
        close_btn = Button(
            text='×',
            size_hint=(None, None),
            size=(dp(40), dp(40)),
            pos_hint={'right': 1, 'top': 1},
            background_color=(0, 0, 0, 0.5),
            color=(1, 1, 1, 1),
            font_size=dp(24),
            bold=True
        )
        
        content.add_widget(full_image)
        content.add_widget(close_btn)
        
        # Create popup
        popup = Popup(
            title='',
            content=content,
            size_hint=(1, 1),
            background='',
            background_color=(0, 0, 0, 0.9)
        )
        
        def close_popup(instance):
            popup.dismiss()
        
        close_btn.bind(on_release=close_popup)
        popup.open()
        
        return True

    def delete_message(self, instance):
        # Traverse up the widget tree to find the HomeScreen instance
        parent = self.parent
        while parent is not None and not isinstance(parent, HomeScreen):
            parent = parent.parent
        if parent and isinstance(parent, HomeScreen):
            print(f"Deleting message with id: {self.message_id}")
            # Remove from messages list
            parent.messages = [m for m in parent.messages if m.get('id') != self.message_id]
            # Save changes
            parent.save_messages()
            # Remove widget
            if hasattr(parent, 'chat_layout'):
                parent.chat_layout.remove_widget(self)

    def _update_rect(self, instance, value):
        self.bg.pos = instance.pos
        self.bg.size = instance.size
        self.shadow.pos = (instance.x + dp(2), instance.y - dp(2))
        self.shadow.size = instance.size

    def update_theme(self, *args):
        is_dark = self.theme_manager.is_dark_mode
        # Update background and shadow colors
        if hasattr(self, 'bg_color'):
            self.bg_color.rgba = (0.2, 0.2, 0.22, 1) if is_dark else (0.95, 0.95, 0.95, 1)
        if hasattr(self, 'shadow_color'):
            self.shadow_color.rgba = (0, 0, 0, 0.3) if is_dark else (0, 0, 0, 0.1)
        # Update text colors
        self.username_label.color = (0.9, 0.9, 0.9, 1) if is_dark else (0.2, 0.2, 0.2, 1)
        self.time_label.color = (0.7, 0.7, 0.7, 1) if is_dark else (0.5, 0.5, 0.5, 1)
        self.message_label.color = (0.9, 0.9, 0.9, 1) if is_dark else (0.3, 0.3, 0.3, 1)

    def format_timestamp(self, timestamp):
        if not timestamp:
            return datetime.now().strftime('%H:%M')
        
        try:
            # Parse the timestamp
            if isinstance(timestamp, str):
                # Try to parse the timestamp string
                try:
                    dt = datetime.strptime(timestamp, '%Y-%m-%d %H:%M:%S')
                except ValueError:
                    try:
                        dt = datetime.strptime(timestamp, '%H:%M')
                        dt = dt.replace(year=datetime.now().year, month=datetime.now().month, day=datetime.now().day)
                    except ValueError:
                        return timestamp
            else:
                dt = timestamp
            
            now = datetime.now()
            diff = now - dt
            
            # Today
            if dt.date() == now.date():
                return dt.strftime('%H:%M')
            
            # Yesterday
            if dt.date() == now.date() - timedelta(days=1):
                return 'Yesterday'
            
            # This week
            if diff.days < 7:
                return dt.strftime('%A')  # Monday, Tuesday, etc.
            
            # Last week
            if diff.days < 14:
                return 'Last ' + dt.strftime('%A')
            
            # This month
            if dt.month == now.month and dt.year == now.year:
                return dt.strftime('%d %B')
            
            # This year
            if dt.year == now.year:
                return dt.strftime('%d %B')
            
            # Older
            return dt.strftime('%d/%m/%Y')
            
        except Exception as e:
            print(f"Error formatting timestamp: {e}")
            return timestamp
