from kivy.app import App
from kivy.uix.screenmanager import Screen, SlideTransition
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.button import Button
from kivy.uix.label import Label
from kivy.graphics import Color, Rectangle, RoundedRectangle, Ellipse, Line, Triangle
from kivy.graphics import StencilPush, StencilUse, StencilUnUse, StencilPop
from kivy.metrics import dp
from kivy.uix.floatlayout import FloatLayout
from kivy.uix.anchorlayout import AnchorLayout
from kivy.uix.widget import Widget
from kivy.uix.behaviors import ButtonBehavior, ToggleButtonBehavior
from kivy.properties import StringProperty, BooleanProperty, ObjectProperty
from kivy.uix.image import Image
from kivy.core.window import Window
from kivy.uix.spinner import Spinner
from kivy.uix.scrollview import ScrollView
from kivy.uix.gridlayout import GridLayout
from kivy.uix.textinput import TextInput
from kivy.clock import Clock
from datetime import datetime, timedelta
import os
import threading
import math
from round_button import RoundButtonArea
from theme_manager import ThemeManager
from kivy.uix.relativelayout import RelativeLayout
from kivy.uix.switch import Switch
from kivy.uix.dropdown import DropDown
from kivy.uix.popup import Popup
from bordered_button import BorderedButton

# Define language settings
LANGUAGES = ['en', 'ro', 'ru']
CURRENT_LANGUAGE = {'lang': 'en'}  # Default language

# Translation dictionaries
LANG_DICT = {
    'en': {
        'login': 'Login',
        'username': 'Username',
        'password': 'Password',
        'register': 'Register',
        'home_page': 'Home',
        'welcome': 'Welcome',
        'settings': 'Settings',
        'notifications': 'Notifications',
        'dark_mode': 'Dark Mode',
        'sound': 'Sound',
        'vibration': 'Vibration',
        'language': 'Language',
        'logout': 'Logout',
        'add': 'ADD',
        'no_reminders_yet': 'No antibiotic reminders yet.\nTap + to create a new reminder.',
        'ready': 'READY',
        'due_now': 'DUE NOW',
        'minutes': 'min',
        'taken': 'TAKEN',
        'take_now': 'TAKE NOW',
        'delete': 'Delete',
        'edit': 'Edit',
        'ask_ai_assistant': 'Ask AI about this medication',
        'ai_assistant_description': 'I can help with information about antibiotics, setting up reminders, or answering questions about your medication. How can I assist you today?',
        'back_to_home': 'Back to Home',
        'antibiotic_reminder': 'Antibiotic Reminder',
        'add_new_antibiotic_reminder': 'Add New Antibiotic Reminder',
        'edit_antibiotic_reminder': 'Edit Antibiotic Reminder',
        'medication_name': 'Medication Name',
        'dosage': 'Dosage',
        'frequency': 'Frequency',
        'duration_days': 'Duration (days)',
        'notes_optional': 'Notes (optional)',
        'special_instructions': 'Special Instructions',
        'enter_medication_name': 'Enter medication name (e.g., Amoxicillin)',
        'enter_dosage': 'Enter dosage (e.g., 500mg)',
        'select_frequency': 'Select frequency',
        'enter_duration': 'Enter number of days (e.g., 7)',
        'cancel': 'Cancel',
        'save': 'Save',
        'ask_ai': 'Ask AI',
        'type_your_question_here': 'Type your question here',
        'text_secondary': 'Secondary text color',
        'mediscan': 'MediScan',
        'medical_assistant': 'Medical Assistant',
        'ask_about_medication': 'Ask about your medication',
        'type_message_here': 'Type your message here',
        'assistant_not_available': 'Assistant module not available',
        'welcome_message': 'Hello! I\'m your medical assistant. I can help with information about medications, setting up reminders, or answering questions about your treatment. How can I assist you today?',
        'show_password': 'Show password',
        'sign_up': 'Sign up',
        'back_to_login': 'Back to login',
        'restart_for_language': 'App restart is needed for full translation'
    },
    'ro': {
        'login': 'Autentificare',
        'username': 'Nume utilizator',
        'password': 'Parolă',
        'register': 'Înregistrare',
        'home_page': 'Acasă',
        'welcome': 'Bine ați venit',
        'settings': 'Setări',
        'notifications': 'Notificări',
        'dark_mode': 'Mod întunecat',
        'sound': 'Sunet',
        'vibration': 'Vibrație',
        'language': 'Limbă',
        'logout': 'Deconectare',
        'add': 'ADAUGĂ',
        'no_reminders_yet': 'Nu există memento-uri pentru antibiotice.\nAtinge + pentru a crea primul reminder.',
        'ready': 'GATA',
        'due_now': 'ACUM',
        'minutes': 'min',
        'taken': 'LUAT',
        'take_now': 'IA ACUM',
        'delete': 'Șterge',
        'edit': 'Editează',
        'ask_ai_assistant': 'Întreabă AI despre această medicament',
        'ai_assistant_description': 'Pot ajuta cu informații despre antibiotice, setarea unor reminder-uri sau răspuns la întrebări despre medicament. Ce pot face pentru tine astăzi?',
        'back_to_home': 'Înapoi la Home',
        'antibiotic_reminder': 'Reminder Antibiotice',
        'add_new_antibiotic_reminder': 'Adaugă un nou reminder pentru antibiotice',
        'edit_antibiotic_reminder': 'Editează reminderul pentru antibiotice',
        'medication_name': 'Nume medicament',
        'dosage': 'Doză',
        'frequency': 'Frecvență',
        'duration_days': 'Durată (zile)',
        'notes_optional': 'Note (opționale)',
        'special_instructions': 'Instrucțiuni speciale',
        'enter_medication_name': 'Introduceți numele medicamentului (e.g., Amoxicillin)',
        'enter_dosage': 'Introduceți doza (e.g., 500mg)',
        'select_frequency': 'Selectați frecvența',
        'enter_duration': 'Introduceți numărul de zile (e.g., 7)',
        'cancel': 'Anulare',
        'save': 'Salvare',
        'ask_ai': 'Întreabă AI',
        'type_your_question_here': 'Introduceți mesajul dvs. aici',
        'text_secondary': 'Culoare text secundară',
        'mediscan': 'MediScan',
        'medical_assistant': 'Asistent Medical',
        'ask_about_medication': 'Întreabă despre medicamentul tău',
        'type_message_here': 'Scrie mesajul tău aici',
        'assistant_not_available': 'Modulul asistent nu este disponibil',
        'welcome_message': 'Bună! Sunt asistentul tău medical. Te pot ajuta cu informații despre medicamente, setarea unor reminder-uri sau răspuns la întrebări despre tratamentul tău. Cu ce te pot ajuta astăzi?',
        'show_password': 'Arată parola',
        'sign_up': 'Înregistrare',
        'back_to_login': 'Înapoi la autentificare'
    },
    'ru': {
        'login': 'Вход',
        'username': 'Имя пользователя',
        'password': 'Пароль',
        'register': 'Регистрация',
        'home_page': 'Главная',
        'welcome': 'Добро пожаловать',
        'settings': 'Настройки',
        'notifications': 'Уведомления',
        'dark_mode': 'Темный режим',
        'sound': 'Звук',
        'vibration': 'Вибрация',
        'language': 'Язык',
        'logout': 'Выход',
        'add': 'ДОБАВИТЬ',
        'no_reminders_yet': 'Нет напоминаний о приеме антибиотиков.\nНажмите + чтобы создать первое напоминание.',
        'ready': 'ГОТОВО',
        'due_now': 'СЕЙЧАС',
        'minutes': 'мин',
        'taken': 'ПРИНЯТО',
        'take_now': 'ПРИНЯТЬ',
        'delete': 'Удалить',
        'edit': 'Изменить',
        'ask_ai_assistant': 'Спросите AI о этом лекарстве',
        'ai_assistant_description': 'Я могу помочь с информацией о антибиотиках, настройкой напоминаний или ответом на вопросы о вашем лекарстве. Как я могу вам помочь сегодня?',
        'back_to_home': 'На главную',
        'antibiotic_reminder': 'Напоминание об антибиотиках',
        'add_new_antibiotic_reminder': 'Добавить новое напоминание об антибиотиках',
        'edit_antibiotic_reminder': 'Редактировать напоминание об антибиотиках',
        'medication_name': 'Название лекарства',
        'dosage': 'Доза',
        'frequency': 'Частота',
        'duration_days': 'Продолжительность (дни)',
        'notes_optional': 'Примечания (необязательно)',
        'special_instructions': 'Специальные инструкции',
        'enter_medication_name': 'Введите название лекарства (например, Амoxicillin)',
        'enter_dosage': 'Введите дозу (например, 500mg)',
        'select_frequency': 'Выберите частоту',
        'enter_duration': 'Введите количество дней (например, 7)',
        'cancel': 'Отмена',
        'save': 'Сохранить',
        'ask_ai': 'Спросить AI',
        'type_your_question_here': 'Введите ваш вопрос здесь',
        'text_secondary': 'Вторичный цвет текста',
        'mediscan': 'MediScan',
        'medical_assistant': 'Медицинский Ассистент',
        'ask_about_medication': 'Спросите о вашем лекарстве',
        'type_message_here': 'Введите ваше сообщение здесь',
        'assistant_not_available': 'Модуль ассистента недоступен',
        'welcome_message': 'Здравствуйте! Я ваш медицинский ассистент. Я могу помочь с информацией о лекарствах, настройкой напоминаний или ответом на вопросы о вашем лечении. Как я могу вам помочь сегодня?',
        'show_password': 'Показать пароль',
        'sign_up': 'Регистрация',
        'back_to_login': 'Вернуться к входу'
    }
}

# Global translation function
def tr(key):
    lang = CURRENT_LANGUAGE['lang']
    return LANG_DICT.get(lang, LANG_DICT['en']).get(key, key)

# Language Manager for handling translations
from kivy.event import EventDispatcher
from kivy.properties import StringProperty

class LanguageManager(EventDispatcher):
    """
    Manages language settings for the application.
    Implemented as a singleton to ensure consistent language across the app.
    """
    _instance = None
    current_language = StringProperty('en')  # Default to English
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(LanguageManager, cls).__new__(cls)
            EventDispatcher.__init__(cls._instance)
            cls._instance.current_language = CURRENT_LANGUAGE['lang']
        return cls._instance
    
    def __init__(self):
        """Initialize language manager"""
        # This will only be called once due to the singleton pattern
        if not hasattr(self, 'is_initialized'):
            self.is_initialized = True
    
    def set_language(self, lang_code):
        """Set the current language"""
        if lang_code in LANGUAGES:
            # Update global language
            CURRENT_LANGUAGE['lang'] = lang_code
            # Update instance language - this triggers bindings
            self.current_language = lang_code
    
    def get_language(self):
        """Get the current language code"""
        return self.current_language
    
    def get_text(self, key):
        """Get translated text for a key"""
        lang = self.current_language
        
        if lang in LANG_DICT and key in LANG_DICT[lang]:
            return LANG_DICT[lang][key]
        
        # Fallback to English
        if 'en' in LANG_DICT and key in LANG_DICT['en']:
            return LANG_DICT['en'][key]
        
        # Return the key itself if not found
        return key

# Base Screen for all other screens
class BaseScreen(Screen):
    def __init__(self, **kwargs):
        # Extract auto_update_theme parameter with default value True
        self.auto_update_theme = kwargs.pop('auto_update_theme', True)
        
        super(BaseScreen, self).__init__(**kwargs)
        self.theme_manager = ThemeManager()
        self.language_manager = LanguageManager()
        
        # Main layout with theme-based background
        self.main_layout = FloatLayout()
        
        # Set background color based on theme
        with self.main_layout.canvas.before:
            self.bg_color = Color(1, 1, 1, 1)  # Default to white
            self.bg_rect = Rectangle(pos=self.main_layout.pos, size=self.main_layout.size)
            self.main_layout.bind(pos=self._update_rect, size=self._update_rect)
        
        # Add a back arrow button to return to home
        self.back_button = Button(
            text='<',
            font_size=dp(24),
            size_hint=(None, None),
            size=(dp(60), dp(60)),  # Updated to match reminder section
            pos_hint={'x': 0, 'top': 1},
            background_normal='',
            background_color=(0.92, 0.92, 0.92, 1),  # Light grey color to match nav bar
            color=(0.2, 0.2, 0.2, 1)  # Dark text for better contrast on light background
        )
        self.back_button.bind(on_press=self.go_back)
        self.main_layout.add_widget(self.back_button)
        
        self.add_widget(self.main_layout)
        
        # Update theme if auto_update_theme is True
        if self.auto_update_theme:
            self.update_theme()
        
        # Bind to theme changes
        self.theme_manager.bind(is_dark_mode=self.update_theme)
    
    def _update_rect(self, instance, value):
        self.bg_rect.pos = instance.pos
        self.bg_rect.size = instance.size
    
    def update_theme(self, *args):
        """Update the theme colors"""
        colors = self.theme_manager.get_colors()
        
        # Update background color
        if hasattr(self, 'bg_color'):
            self.bg_color.rgba = colors['background']
        
        # Update back button colors - always keep light grey regardless of theme
        if hasattr(self, 'back_button'):
            if self.theme_manager.is_dark_mode:
                self.back_button.background_color = (0.2, 0.2, 0.22, 1)  # Darker grey for dark mode
                self.back_button.color = (0.9, 0.9, 0.9, 1)  # Light text for dark mode
            else:
                self.back_button.background_color = (0.92, 0.92, 0.92, 1)  # Light grey for light mode
                self.back_button.color = (0.2, 0.2, 0.2, 1)  # Dark text for light mode
                
        # Update all widgets with theme colors
        for child in self.walk(restrict=True):
            # Update labels
            if isinstance(child, Label):
                if getattr(child, 'bold', False) and getattr(child, 'font_size', 0) > dp(18):
                    # This is likely a title - use primary color
                    child.color = colors.get('primary', colors['text'])
                else:
                    # Regular text
                    child.color = colors['text']
            
            # Update standard buttons
            elif isinstance(child, Button) and child != self.back_button:
                # Only update standard buttons, not custom ones
                if not any(isinstance(child, cls) for cls in [RoundedButton, IconButton]):
                    child.background_color = colors['button_bg']
                    child.color = colors['button_text']
                    
            # Update text inputs
            elif isinstance(child, TextInput):
                child.background_color = colors['input_bg']
                child.foreground_color = colors['text']
                child.cursor_color = colors['primary']
    
    def go_back(self, *args):
        """Navigate back to the home screen"""
        self.manager.current = 'home'

class IconWidget(Widget):
    def __init__(self, icon_type='', **kwargs):
        super(IconWidget, self).__init__(**kwargs)
        self.icon_type = icon_type
        self.size_hint = (None, None)
        self.size = (dp(30), dp(30))
        self.bind(pos=self.update_canvas)
        self.bind(size=self.update_canvas)
    
    def update_canvas(self, *args):
        self.canvas.clear()
        with self.canvas:
            Color(0.2, 0.2, 0.2, 1)  # Dark gray color for icons
            
            if self.icon_type == 'home':
                # House icon
                points = [
                    self.center_x, self.top,  # Top of roof
                    self.x + dp(4), self.center_y + dp(4),  # Left roof
                    self.x + dp(4), self.y + dp(4),  # Left wall
                    self.right - dp(4), self.y + dp(4),  # Bottom wall
                    self.right - dp(4), self.center_y + dp(4),  # Right wall
                    self.center_x, self.top  # Back to top
                ]
                Line(points=points, width=dp(1.5))
                # Door
                door_points = [
                    self.center_x - dp(4), self.y + dp(4),  # Door left
                    self.center_x - dp(4), self.center_y - dp(4),  # Door top left
                    self.center_x + dp(4), self.center_y - dp(4),  # Door top right
                    self.center_x + dp(4), self.y + dp(4)  # Door right
                ]
                Line(points=door_points, width=dp(1.5))
                
            elif self.icon_type == 'reminder':
                # Clock icon
                Line(circle=(self.center_x, self.center_y, min(self.width, self.height)/2 - dp(4)), width=dp(1.5))
                # Clock hands
                Line(points=[self.center_x, self.center_y, self.center_x, self.top - dp(8)], width=dp(1.5))
                Line(points=[self.center_x, self.center_y, self.right - dp(8), self.center_y], width=dp(1.5))
                
            elif self.icon_type == 'camera':
                # Camera body
                Line(rectangle=(self.x + dp(4), self.y + dp(4), self.width - dp(8), self.height - dp(8)), width=dp(1.5))
                # Lens
                Line(circle=(self.center_x, self.center_y, min(self.width, self.height)/4), width=dp(1.5))
                # Flash
                Line(rectangle=(self.right - dp(8), self.top - dp(12), dp(4), dp(4)), width=dp(1.5))
                
            elif self.icon_type == 'voice':
                # YouTube-style microphone icon
                # Microphone stand
                Line(points=[
                    self.center_x, self.y + dp(4),
                    self.center_x, self.top - dp(4)
                ], width=dp(2))
                # Microphone head (circle)
                Line(circle=(self.center_x, self.top - dp(4), dp(6)), width=dp(2))
                # Microphone base (small rectangle)
                Line(rectangle=(self.center_x - dp(4), self.y + dp(4), dp(8), dp(2)), width=dp(2))
                
            elif self.icon_type == 'settings':
                # Gear icon
                Line(circle=(self.center_x, self.center_y, min(self.width, self.height)/3), width=dp(1.5))
                # Gear teeth
                for i in range(8):
                    angle = i * math.pi / 4
                    radius = min(self.width, self.height)/2 - dp(4)
                    x1 = self.center_x + radius * 0.7 * math.cos(angle)
                    y1 = self.center_y + radius * 0.7 * math.sin(angle)
                    x2 = self.center_x + radius * math.cos(angle)
                    y2 = self.center_y + radius * math.sin(angle)
                    Line(points=[x1, y1, x2, y2], width=dp(1.5))

class IconButton(ButtonBehavior, BoxLayout):
    icon_type = StringProperty('')
    text = StringProperty('')
    
    def __init__(self, **kwargs):
        super(IconButton, self).__init__(**kwargs)
        self.theme_manager = ThemeManager()
        self.orientation = 'vertical'
        self.size_hint = (1, 1)
        self.spacing = dp(5)
        self.padding = dp(5)
        
        # Create an image widget for the icon
        self.icon_image = Image(
            source='',  # Will be set by _update_icon
            size_hint=(None, None),
            size=(dp(35), dp(35)),  # Increased from 30 to 35
            allow_stretch=True,
            keep_ratio=True,
            color=(0.2, 0.2, 0.2, 1)  # Initial color, will be updated by theme
        )
        
        # Center the icon
        icon_layout = AnchorLayout(
            anchor_x='center',
            anchor_y='center',
            size_hint=(1, 0.7)
        )
        
        icon_layout.add_widget(self.icon_image)
        self.add_widget(icon_layout)
        
        # Create label
        label_layout = AnchorLayout(
            anchor_x='center',
            anchor_y='center',
            size_hint=(1, 0.3)
        )
        self.label = Label(
            text=self.text,
            font_size=dp(11),
            color=(0.2, 0.2, 0.2, 1),  # Will be updated by theme
            size_hint=(1, None),
            height=dp(20),
            bold=True,
            halign='center'
        )
        label_layout.add_widget(self.label)
        self.add_widget(label_layout)
        
        # Bind properties
        self.bind(icon_type=self._update_icon)
        self.bind(text=self._update_text)
        
        # Initialize icon if icon_type was provided in kwargs
        if 'icon_type' in kwargs:
            self._update_icon(self, kwargs['icon_type'])
        
        # Update theme initially and bind to theme changes
        self.update_theme()
        self.theme_manager.bind(is_dark_mode=self.update_theme)
    
    def _update_icon(self, instance, value):
        # Map icon types to icon image files with absolute paths
        import os
        app_dir = os.path.dirname(os.path.abspath(__file__))
        icon_mapping = {
            'home': os.path.join(app_dir, 'icons', 'home-icon-silhouette.png'),
            'reminder': os.path.join(app_dir, 'icons', 'bell.png'),
            'mediscan': os.path.join(app_dir, 'icons', 'x-ray.png'),
            'voice': os.path.join(app_dir, 'icons', 'microphone.png'),
            'settings': os.path.join(app_dir, 'icons', 'setting.png')
        }
        
        # Get the absolute path to the icon
        icon_path = icon_mapping.get(value, '')
        if icon_path and os.path.exists(icon_path):
            # Set the source and ensure it's visible
            self.icon_image.source = icon_path
            # Set larger size specifically for MediScan icon
            if value == 'mediscan':
                self.icon_image.size = (dp(45), dp(45))
            else:
                self.icon_image.size = (dp(35), dp(35))
            self.icon_image.opacity = 1
        else:
            # Hide the icon if no path is found or file doesn't exist
            self.icon_image.opacity = 0
    
    def _update_text(self, instance, value):
        self.label.text = value
        self.update_theme()  # Update colors based on current theme
    
    def update_theme(self, *args):
        """Update colors based on current theme"""
        is_dark = self.theme_manager.is_dark_mode
        
        # Update icon and text colors based on theme
        if is_dark:
            self.icon_image.color = (0.9, 0.9, 0.9, 1)  # Light color for dark mode
            self.label.color = (0.9, 0.9, 0.9, 1)
        else:
            self.icon_image.color = (0.2, 0.2, 0.2, 1)  # Dark color for light mode
            self.label.color = (0.2, 0.2, 0.2, 1)
    
    def on_press(self):
        # Change to a pressed state color based on theme
        is_dark = self.theme_manager.is_dark_mode
        if is_dark:
            self.icon_image.color = (1, 1, 1, 1)  # White for dark mode
            self.label.color = (1, 1, 1, 1)
        else:
            self.icon_image.color = (0, 0, 0, 1)  # Black for light mode
            self.label.color = (0, 0, 0, 1)
        
        # Get the HomeScreen instance to handle navigation
        app = App.get_running_app()
        if hasattr(app.root.current_screen, 'navigate_to'):
            app.root.current_screen.navigate_to(self.icon_type)
    
    def on_release(self):
        # Restore colors based on current theme
        self.update_theme()

# Reminder Screen with antibiotics reminder functionality
from kivy.uix.scrollview import ScrollView
from kivy.uix.gridlayout import GridLayout
from kivy.uix.textinput import TextInput
from kivy.uix.spinner import Spinner
from kivy.metrics import dp
from kivy.graphics import Color, RoundedRectangle
from kivy.properties import ObjectProperty, StringProperty, BooleanProperty
from kivy.clock import Clock
from datetime import datetime, timedelta
import os

# Import the medication reminder module
try:
    from medication_reminder import MedicationReminder
except ImportError:
    pass  # Will handle this in the class

class RoundedButton(Button):
    def __init__(self, **kwargs):
        # Extract our custom properties before passing to the parent class
        self.bg_color = kwargs.pop('bg_color', kwargs.pop('color', (0.2, 0.6, 0.9, 1)))  # Support both bg_color and color
        text_color = kwargs.pop('text_color', (1, 1, 1, 1))  # Default white text
        
        # Now call the parent with the cleaned kwargs
        super(RoundedButton, self).__init__(**kwargs)
        
        # Set up button properties
        self.background_normal = ''
        self.background_color = (0, 0, 0, 0)  # Transparent
        self.background_down = ''
        self.color = text_color  # Text color
        
        # Store the pressed state background color (darken the original color by 20%)
        r, g, b, a = self.bg_color
        self.pressed_bg_color = (max(0, r*0.8), max(0, g*0.8), max(0, b*0.8), a)
        
        # Draw the background with rounded corners
        with self.canvas.before:
            self.color_inst = Color(*self.bg_color)
            self.rect_inst = RoundedRectangle(pos=self.pos, size=self.size, radius=[dp(10)])
            
        # Bind the button position and size to the rect properties
        self.bind(pos=self._update_rect, size=self._update_rect)
        
    def _update_rect(self, instance, value):
        self.rect_inst.pos = instance.pos
        self.rect_inst.size = instance.size
    
    def set_bg_color(self, color):
        """Set background color dynamically"""
        self.bg_color = color
        r, g, b, a = color
        self.pressed_bg_color = (max(0, r*0.8), max(0, g*0.8), max(0, b*0.8), a)
        if hasattr(self, 'color_inst'):
            self.color_inst.rgba = color
    
    # Override the standard button state change behavior
    def on_state(self, instance, value):
        """Handle state changes (normal, down) to provide visual feedback"""
        if value == 'down':
            self.color_inst.rgba = self.pressed_bg_color
        else:
            self.color_inst.rgba = self.bg_color
            
    # Ensure the button receives touch events in its entire bounding box
    def collide_point(self, x, y):
        """Improved collision detection to ensure full button is pressable"""
        return self.x <= x <= self.x + self.width and self.y <= y <= self.y + self.height
        
    def on_touch_down(self, touch):
        """Improved touch handling to make the entire button area clickable"""
        if self.disabled:
            return False
        if self.collide_point(*touch.pos):
            touch.grab(self)
            self.state = 'down'
            self.dispatch('on_press')
            return True
        return super(RoundedButton, self).on_touch_down(touch)
    
    def on_touch_up(self, touch):
        """Handle touch release"""
        if touch.grab_current is self:
            touch.ungrab(self)
            self.state = 'normal'
            self.dispatch('on_release')
            return True
        return super(RoundedButton, self).on_touch_up(touch)

class ReminderCard(BoxLayout):
    reminder_id = StringProperty('')

    def __init__(self, reminder_data, **kwargs):
        super(ReminderCard, self).__init__(**kwargs)
        # Restore all important instance variables
        self.orientation = 'vertical'
        self.size_hint_y = None
        self.height = dp(300)  # Adjusted height for better spacing
        self.padding = [dp(15), dp(15)]
        self.spacing = dp(5)
        self.reminder_data = reminder_data
        self.reminder_id = reminder_data.get('id', '')
        self.theme_manager = ThemeManager()
        self.reminder_manager = None  # This will be set by the ReminderScreen

        # Store next dose time if available
        self.next_dose_time = None
        if reminder_data.get('next_time') and isinstance(reminder_data['next_time'], datetime):
            self.next_dose_time = reminder_data['next_time']

        # Set up doses tracking
        self.frequency = reminder_data.get('frequency', 'Once daily')
        self.duration = int(reminder_data.get('duration', 1))
        self.doses_taken = int(reminder_data.get('doses_taken', 0))
        self.total_doses = self.calculate_total_doses()

        # Configure cooldown duration (in minutes)
        self.cooldown_minutes = 30  # 30 minutes cooldown
        self.in_cooldown = False

        # Create a rounded rectangle for the card background
        with self.canvas.before:
            self.bg_color = Color(0.9, 0.9, 0.9, 1)  # Light gray background
            self.bg_rect = RoundedRectangle(pos=self.pos, size=self.size, radius=[dp(15)])
        
        # Bind to position and size changes to update the background
        self.bind(pos=self._update_rect, size=self._update_rect)
        
        # Title with medication name
        title_layout = BoxLayout(
            orientation='horizontal',
            size_hint=(1, None),
            height=dp(40)
        )
        
        title = Label(
            text=reminder_data.get('medication_name', 'Medication'),
            font_size=dp(20),
            bold=True,
            color=(0.2, 0.2, 0.2, 1),
            halign='left',
            valign='middle',
            size_hint=(1, 1)
        )
        title.bind(size=title.setter('text_size'))
        self.title_label = title
        title_layout.add_widget(title)
        self.add_widget(title_layout)
        
        # Add information about the dosage
        dosage_label = Label(
            text=f"{tr('dosage')}: {reminder_data.get('dosage', '1')} {reminder_data.get('dosage_unit', tr('pill'))}",
            font_size=dp(16),
            color=(0.3, 0.3, 0.3, 1),
            halign='left',
            valign='middle',
            size_hint=(1, None),
            height=dp(30)
        )
        dosage_label.bind(size=dosage_label.setter('text_size'))
        self.dosage_label = dosage_label
        self.add_widget(dosage_label)
        
        # Add information about the frequency
        frequency_label = Label(
            text=f"{tr('frequency')}: {reminder_data.get('frequency', tr('once_daily'))}",
            font_size=dp(16),
            color=(0.3, 0.3, 0.3, 1),
            halign='left',
            valign='middle',
            size_hint=(1, None),
            height=dp(30)
        )
        frequency_label.bind(size=frequency_label.setter('text_size'))
        self.frequency_label = frequency_label
        self.add_widget(frequency_label)
        
        # Add next time information if available
        next_time_text = tr('take_anytime')
        if reminder_data.get('next_time') and isinstance(reminder_data['next_time'], datetime):
            next_time_text = f"{tr('next_dose')}: {self.next_dose_time.strftime('%H:%M')}"
        
        next_time_label = Label(
            text=next_time_text,
            font_size=dp(16),
            color=(0.3, 0.3, 0.3, 1),
            halign='left',
            valign='middle',
            size_hint=(1, None),
            height=dp(30)
        )
        next_time_label.bind(size=next_time_label.setter('text_size'))
        self.next_time_label = next_time_label
        self.add_widget(next_time_label)

        # Add cooldown label
        self.cooldown_label = Label(
            text='',
            font_size=dp(16),
            color=(0.5, 0.2, 0.2, 1),
            halign='left',
            valign='middle',
            size_hint=(1, None),
            height=dp(30)
        )
        self.cooldown_label.bind(size=self.cooldown_label.setter('text_size'))
        self.add_widget(self.cooldown_label)
        
        # Add take button
        take_button = self._create_take_button()
        self.add_widget(take_button)
        
        # Add edit and delete buttons
        buttons_layout = self._create_buttons_layout(reminder_data)
        self.add_widget(buttons_layout)
        
        # Check cooldown status
        self.check_cooldown_status()
    
    def _create_buttons_layout(self, reminder_data):
        """Create the button layout for edit and delete buttons"""
        # Create a row for buttons
        buttons_row = BoxLayout(
            orientation='horizontal',
            size_hint=(1, None),
            height=dp(50),
            spacing=dp(10),
            padding=[dp(0), dp(5), dp(0), dp(5)]
        )
        
        # Edit button with improved styling
        edit_btn = RoundedButton(
            text=tr('edit'),
            size_hint=(0.5, 1),
            bg_color=(0.4, 0.6, 0.8, 1),  # Blue color
            font_size=dp(16),
            bold=True
        )
        edit_btn.bind(on_release=lambda x: self.edit_reminder())
        
        # Delete button with improved styling
        delete_btn = RoundedButton(
            text=tr('delete'),
            size_hint=(0.5, 1),
            bg_color=(0.8, 0.4, 0.4, 1),  # Red color
            font_size=dp(16),
            bold=True
        )
        delete_btn.bind(on_release=lambda x: self.delete_reminder())
        
        buttons_row.add_widget(edit_btn)
        buttons_row.add_widget(delete_btn)
        return buttons_row
    
    def _create_take_button(self):
        """Create the take now button with improved styling"""
        # Container for the take button to improve padding and alignment
        take_btn_container = BoxLayout(
            orientation='vertical',
            size_hint=(1, None),
            height=dp(60),
            padding=[dp(0), dp(5), dp(0), dp(5)]
        )
        
        # Create the take now button with improved styling
        take_btn = RoundedButton(
            text=tr('take_now'),
            size_hint=(1, 1),
            bg_color=(0.2, 0.8, 0.2, 1),  # Green color
            font_size=dp(16),
            bold=True
        )
        take_btn.bind(on_release=lambda x: self.take_dose())
        
        take_btn_container.add_widget(take_btn)
        return take_btn_container
    
    def check_cooldown_status(self):
        """Check if medication can be taken again"""
        if self.in_cooldown:
            self.cooldown_label.text = f"Cooldown: {self.cooldown_minutes} minutes"
            return
        
        now = datetime.now()
        if self.next_dose_time and now < self.next_dose_time:
            time_left = self.next_dose_time - now
            self.cooldown_label.text = f"Cooldown: {time_left.seconds // 60} minutes"
            self.in_cooldown = True
        else:
            self.cooldown_label.text = tr('ready')
            self.in_cooldown = False
    
    def take_dose(self):
        """Mark a dose as taken"""
        if self.in_cooldown:
            # Cannot take dose while in cooldown
            self.show_cooldown_message()
            return
        
        # Visual feedback - briefly change button color
        take_btn = None
        for child in self.walk():
            if isinstance(child, RoundedButton) and child.text == tr("take_now"):
                take_btn = child
                break
        
        if take_btn:
            # Store original color
            original_color = take_btn.bg_color
            
            # Change to a bright confirmation color
            take_btn.bg_color = (0.3, 1.0, 0.3, 1)
            
            # Schedule restoration of original color after brief delay
            def restore_color(dt):
                take_btn.bg_color = original_color
            
            Clock.schedule_once(restore_color, 0.3)
        
        # Increment doses taken
        self.doses_taken += 1
        
        # Update the UI
        if hasattr(self, 'doses_value'):
            self.doses_value.text = f"{self.doses_taken}/{self.total_doses} taken"
        
        # Update reminder data in the manager
        if self.reminder_manager:
            self.reminder_manager.update_doses_taken(self.reminder_id, self.doses_taken)
            
            # If using schedule, update next dose time
            if self.next_dose_time is not None:
                # Compute next dose time based on frequency
                next_time = self.calculate_next_dose_time()
                self.next_dose_time = next_time
                self.reminder_manager.update_next_time(self.reminder_id, next_time)
        
        # Set cooldown to prevent rapid button presses
        self.start_cooldown()
        
        # Update cooldown status immediately
        self.check_cooldown_status()
    
    def start_cooldown(self):
        """Start the cooldown timer"""
        self.next_dose_time = datetime.now() + timedelta(minutes=self.cooldown_minutes)
        self.in_cooldown = True
        self.cooldown_label.text = f"Cooldown: {self.cooldown_minutes} minutes"
    
    def show_cooldown_message(self):
        """Show a toast message indicating that the cooldown is active"""
        # Create a popup toast
        toast = Popup(
            title='',
            content=Label(
                text="Please wait before taking another dose.",
                color=(1, 1, 1, 1)
            ),
            size_hint=(None, None),
            size=(dp(300), dp(100)),
            background_color=(0.3, 0.3, 0.3, 0.8),
            auto_dismiss=True
        )
        toast.open()
        # Schedule auto-dismiss after 2 seconds
        Clock.schedule_once(lambda dt: toast.dismiss(), 2)
    
    def calculate_next_dose_time(self):
        """Calculate the next dose time based on the current frequency"""
        frequency = self.reminder_data.get('frequency', 'Once daily')
        if frequency == 'Once daily':
            return datetime.now() + timedelta(days=1)
        elif frequency == 'Twice daily':
            return datetime.now() + timedelta(hours=12)
        elif frequency == 'Three times daily':
            return datetime.now() + timedelta(hours=8)
        elif frequency == 'Four times daily':
            return datetime.now() + timedelta(hours=6)
        elif frequency == 'Every 1 hour':
            return datetime.now() + timedelta(hours=1)
        elif frequency == 'Every 2 hours':
            return datetime.now() + timedelta(hours=2)
        elif frequency == 'Every 3 hours':
            return datetime.now() + timedelta(hours=3)
        elif frequency == 'Every 4 hours':
            return datetime.now() + timedelta(hours=4)
        elif frequency == 'Every 5 hours':
            return datetime.now() + timedelta(hours=5)
        elif frequency == 'Every 6 hours':
            return datetime.now() + timedelta(hours=6)
        elif frequency == 'Every 8 hours':
            return datetime.now() + timedelta(hours=8)
        elif frequency == 'Every 10 hours':
            return datetime.now() + timedelta(hours=10)
        elif frequency == 'Every 12 hours':
            return datetime.now() + timedelta(hours=12)
        else:
            raise ValueError("Invalid frequency format")
    
    def edit_reminder(self):
        # Signal to parent screen to edit this reminder
        screen = App.get_running_app().root.current_screen
        if hasattr(screen, 'show_edit_reminder'):
            screen.show_edit_reminder(self.reminder_id)
    
    def delete_reminder(self):
        # Signal to parent screen to delete this reminder
        screen = App.get_running_app().root.current_screen
        if hasattr(screen, 'delete_reminder'):
            screen.delete_reminder(self.reminder_id)

    def update_card_data(self, reminder_data):
        """Update card data while preserving state"""
        # Store original state
        original_doses_taken = getattr(self, 'doses_taken', 0)
        original_next_dose_time = getattr(self, 'next_dose_time', None)
        
        # Update with new data but preserve key state
        self.reminder_data = reminder_data
        self.reminder_id = reminder_data.get('id', '')
        
        # Recalculate frequency and duration info
        self.frequency = reminder_data.get('frequency', 'Once daily')
        self.duration = int(reminder_data.get('duration', 1))
        
        # Update UI elements if they exist
        if hasattr(self, 'title'):
            self.title.text = reminder_data.get('medication_name', 'Medication')
        
        if hasattr(self, 'dosage_value'):
            self.dosage_value.text = reminder_data.get('dosage', 'N/A')
            
        if hasattr(self, 'frequency_value'):
            self.frequency_value.text = self.frequency
            
        if hasattr(self, 'duration_value'):
            self.duration_value.text = f"{self.duration} day{'s' if self.duration > 1 else ''}"
        
        # Preserve doses taken - use the higher of the two values
        new_doses_taken = int(reminder_data.get('doses_taken', 0))
        self.doses_taken = max(original_doses_taken, new_doses_taken)
        
        if hasattr(self, 'doses_value'):
            self.doses_value.text = f"{self.doses_taken}/{self.total_doses} taken"
        
        # Preserve next dose time if it exists
        if original_next_dose_time and isinstance(original_next_dose_time, datetime):
            # Keep existing next_dose_time to avoid resetting countdown
            self.next_dose_time = original_next_dose_time
        elif reminder_data.get('next_time') and isinstance(reminder_data['next_time'], datetime):
            # Use the new next_time if no existing one
            self.next_dose_time = reminder_data['next_time']
            
        # Update cooldown status
        self.check_cooldown_status()

    def add_message(self, message):
        """Add a message to the chat"""
        # Create a new chat bubble
        bubble = ChatBubble(message, is_user=False)
        
        # Add to the chat layout at the bottom
        self.chat_layout.add_widget(bubble)
        
        # Scroll to the bottom to see the new message
        Clock.schedule_once(lambda dt: self._scroll_to_bottom(), 0.1)
    
    def _scroll_to_bottom(self):
        """Scroll the chat view to the bottom"""
        if self.chat_layout.height > self.scroll_view.height:
            self.scroll_view.scroll_y = 0

    def calculate_total_doses(self):
        """Calculate total doses based on frequency and duration"""
        # Take into account that we only count waking hours (16 hours per day)
        doses_per_day = {
            'Once daily': 1,
            'Twice daily': 2,
            'Three times daily': 3, 
            'Four times daily': 4,
            'Every 1 hour': 16,   # 16 waking hours
            'Every 2 hours': 8,
            'Every 3 hours': 5,
            'Every 4 hours': 4,
            'Every 5 hours': 3,
            'Every 6 hours': 3,
            'Every 8 hours': 2,
            'Every 10 hours': 2,
            'Every 12 hours': 1
        }
        return doses_per_day.get(self.frequency, 1) * self.duration

    def _update_rect(self, instance, value):
        """Update the background rectangle position and size"""
        if hasattr(self, 'bg_rect'):
            self.bg_rect.pos = self.pos
            self.bg_rect.size = self.size

class ReminderScreen(BaseScreen):
    reminder_manager = ObjectProperty(None)
    is_adding_reminder = BooleanProperty(False)
    editing_reminder_id = StringProperty('')
    form_visible = BooleanProperty(False)  # Track form visibility
    
    def __init__(self, **kwargs):
        # Pass auto_update_theme=False to prevent premature call to update_theme
        super(ReminderScreen, self).__init__(auto_update_theme=False, **kwargs)
        
        # Store theme for later use
        self.is_dark_mode = self.theme_manager.is_dark_mode
        
        # Make the back button larger and positioned in the corner
        self.back_button.size = (dp(60), dp(60))
        self.back_button.font_size = dp(24)
        self.back_button.pos_hint = {'x': 0, 'top': 1}
        self.back_button.background_color = (0.8, 0.8, 0.8, 1)  # Grey color
        
        # Initialize the medication reminder manager
        try:
            self.reminder_manager = MedicationReminder()
        except NameError:
            print("MedicationReminder class not found, using a mock implementation")
            from medication_reminder_mock import MockMedicationReminder
            self.reminder_manager = MockMedicationReminder()
        
        self.language_manager = LanguageManager()
        
        # Bind to theme changes to update frequency button color
        self.theme_manager.bind(is_dark_mode=self._on_theme_change)
        
        # Add title with more modern styling - dark grey and centered
        title_bar = BoxLayout(
            orientation='horizontal',
            size_hint=(1, None),
            height=dp(80),  # Increased height for more space
            pos_hint={'top': 1},
            padding=[0, dp(15), 0, 0]  # Add padding to the top
        )
        
        self.title_label = Label(
            text=tr('antibiotic_reminder'),
            font_size=dp(30),  # Increased font size
            bold=True,
            color=(0.3, 0.3, 0.3, 1),  # Dark grey text
            size_hint=(1, 1),
            halign='center',  # Centered text
            valign='middle',
            pos_hint={'center_x': 0.5, 'center_y': 0.5}  # Centered horizontally and vertically
        )
        # Ensure the text alignment applies
        self.title_label.bind(size=self.title_label.setter('text_size'))
        
        title_bar.add_widget(self.title_label)
        self.main_layout.add_widget(title_bar)
        
        # Content area for reminders with scroll view - optimize for scrolling
        self.scroll_view = ScrollView(
            size_hint=(1, None),
            height=dp(500),  # Increased from 400 to 500
            pos_hint={'center_x': 0.5, 'top': 0.9},
            do_scroll_x=False,  # Only allow vertical scrolling
            do_scroll_y=True,   # Explicitly enable vertical scrolling
            scroll_type=['content', 'bars'],  # Better scrolling behavior
            bar_width=dp(10),   # Make the scrollbar wider and more visible
            bar_color=(0.7, 0.7, 0.7, 0.9),  # Make scrollbar more visible
            bar_inactive_color=(0.7, 0.7, 0.7, 0.2),
            effect_cls='ScrollEffect'  # Use simpler scroll effect for better performance
        )
        
        # This will hold our reminder cards
        self.reminders_layout = GridLayout(
            cols=1,
            spacing=dp(15),
            padding=[dp(10), dp(10)],
            size_hint_y=None,  # Required for scrolling
        )
        self.reminders_layout.bind(minimum_height=self.reminders_layout.setter('height'))
        
        self.scroll_view.add_widget(self.reminders_layout)
        self.main_layout.add_widget(self.scroll_view)
        
        # Create a circular Add button at the bottom center of the page
        add_button_container = BoxLayout(
            orientation='vertical',
            size_hint=(None, None),
            width=dp(90),
            height=dp(100),  # Reduced from 120 to 100
            pos_hint={'center_x': 0.5, 'y': 0.02}  # Lowered from 0.07 to 0.02
        )
        
        # Use our custom RoundButton that guarantees the whole circle is clickable
        from round_button import RoundButton
        
        # Create a circular button with proper touch detection
        circle_btn = RoundButton(
            text='+',
            font_size=dp(42),
            bold=True,
            size_hint=(None, None),
            size=(dp(60), dp(60)),
            pos_hint={'center_x': 0.5, 'center_y': 0.5}
        )
        circle_btn.set_colors(bg_color=(0.2, 0.7, 0.3, 1), fg_color=(1, 1, 1, 1))  # Green background, white text
        circle_btn.bind(on_release=self.show_add_reminder)  # Changed from show_add_reminder_popup to show_add_reminder
        
        # Bind directly to the add reminder function
        circle_btn.bind(on_release=self.show_add_reminder)
        
        # Create a centered container for the button
        circle_container = AnchorLayout(
            anchor_x='center', 
            anchor_y='center',
            size_hint=(1, None),
            height=dp(90)  # Give enough room for the button
        )
        
        # Add the circular button directly to the container
        circle_container.add_widget(circle_btn)
        
        # 'ADD' text below the circle
        self.add_text = Label(
            text=tr('add'),
            font_size=dp(14),
            bold=True,
            color=(0.2, 0.7, 0.3, 1),  # Green text to match button
            size_hint=(1, None),
            height=dp(25)
        )
        
        # Add the centered circle and the text to container
        add_button_container.add_widget(circle_container)
        add_button_container.add_widget(self.add_text)
        
        # Store the reference we'll need for callback and updates
        self.circle_plus_btn = circle_btn
        
        # Add to main layout
        self.main_layout.add_widget(add_button_container)
        
        # No reminders message
        self.no_reminders_label = Label(
            text=tr('no_reminders_yet'),
            font_size=dp(18),
            color=(0.6, 0.6, 0.6, 1),
            size_hint=(1, None),
            height=dp(80),
            pos_hint={'center_x': 0.5, 'center_y': 0.5}
        )
        self.main_layout.add_widget(self.no_reminders_label)
        
        # Container for add/edit reminder form (hidden initially)
        self.form_container = FloatLayout(
            size_hint=(1, 1),  # Make it fullscreen
            pos_hint={'center_x': 0.5, 'center_y': 0.5},  # Center it
            opacity=0
        )
        
        # Form background
        with self.form_container.canvas.before:
            # Use color variable so we can update it in the update_theme method
            self.form_bg_color = Color(0.97, 0.97, 0.97, 1)
            self.form_bg = RoundedRectangle(pos=(0, 0), size=(0, 0), radius=[dp(20)])
        self.form_container.bind(pos=self._update_form_bg, size=self._update_form_bg)
        
        # Form contents
        form_grid = GridLayout(
            cols=1,
            spacing=dp(10),  # Reduced spacing from 15 to 10
            padding=[dp(25), dp(15), dp(25), dp(15)],  # Left, top, right, bottom padding
            size_hint=(0.95, 0.95),
            pos_hint={'center_x': 0.5, 'center_y': 0.5}
        )
        
        self.form_title = Label(
            text=tr("add_new_antibiotic_reminder"),
            font_size=dp(20),
            bold=True,
            color=(0.2, 0.4, 0.8, 1),
            size_hint=(1, None),
            height=dp(35)  # Reduced height
        )
        form_grid.add_widget(self.form_title)
        
        # Medication name
        name_layout = BoxLayout(orientation='vertical', size_hint=(1, None), height=dp(70))
        self.name_label = Label(
            text=tr("medication_name"),
            font_size=dp(16),
            color=(0.3, 0.3, 0.3, 1),
            halign='left',
            size_hint=(1, None),
            height=dp(25)
        )
        self.name_label.bind(size=self.name_label.setter('text_size'))
        
        self.name_input = TextInput(
            hint_text=tr("enter_medication_name"),
            multiline=False,
            size_hint=(1, None),
            height=dp(45),
            padding=[dp(10), dp(10)],
            font_size=dp(16)
        )
        name_layout.add_widget(self.name_label)
        name_layout.add_widget(self.name_input)
        form_grid.add_widget(name_layout)
        
        # Dosage
        dosage_layout = BoxLayout(orientation='vertical', size_hint=(1, None), height=dp(70))
        self.dosage_label = Label(
            text=tr("dosage"),
            font_size=dp(16),
            color=(0.3, 0.3, 0.3, 1),
            halign='left',
            size_hint=(1, None),
            height=dp(25)
        )
        self.dosage_label.bind(size=self.dosage_label.setter('text_size'))
        
        self.dosage_input = TextInput(
            hint_text=tr("enter_dosage"),
            multiline=False,
            size_hint=(1, None),
            height=dp(45),
            padding=[dp(10), dp(10)],
            font_size=dp(16)
        )
        dosage_layout.add_widget(self.dosage_label)
        dosage_layout.add_widget(self.dosage_input)
        form_grid.add_widget(dosage_layout)
        
        # Frequency
        frequency_layout = BoxLayout(orientation='vertical', size_hint=(1, None), height=dp(70))
        self.frequency_label = Label(
            text=tr("frequency"),
            font_size=dp(16),
            color=(0.3, 0.3, 0.3, 1),
            halign='left',
            size_hint=(1, None),
            height=dp(25)
        )
        self.frequency_label.bind(size=self.frequency_label.setter('text_size'))
        
        # Create a button with the selected frequency
        self.frequency_button = RoundedButton(
            text=tr("select_frequency"),
            font_size=dp(16),
            bg_color=(0x2a/255, 0x2a/255, 0x2e/255, 1) if self.theme_manager.is_dark_mode else (0xfd/255, 0xde/255, 0x86/255, 1),  # Dark gray in dark mode, yellow in light mode
            color=(0.9, 0.9, 0.9, 1) if self.theme_manager.is_dark_mode else (0, 0, 0, 1),  # Light text in dark mode, dark text in light mode
            size_hint=(1, None),
            height=dp(45)
        )
        
        # Directly bind to toggle_frequency_options
        self.frequency_button.bind(on_release=self.toggle_frequency_options)
        
        frequency_layout.add_widget(self.frequency_label)
        frequency_layout.add_widget(self.frequency_button)
        form_grid.add_widget(frequency_layout)
        
        # Connect spinner directly to button for backward compatibility with existing code
        
        # Duration
        duration_layout = BoxLayout(orientation='vertical', size_hint=(1, None), height=dp(70))
        self.duration_label = Label(
            text=tr("duration_days"),
            font_size=dp(16),
            color=(0.3, 0.3, 0.3, 1),
            halign='left',
            size_hint=(1, None),
            height=dp(25)
        )
        self.duration_label.bind(size=self.duration_label.setter('text_size'))
        
        self.duration_input = TextInput(
            hint_text=tr("enter_duration"),
            multiline=False,
            input_filter='int',
            size_hint=(1, None),
            height=dp(45),
            padding=[dp(10), dp(10)],
            font_size=dp(16)
        )
        duration_layout.add_widget(self.duration_label)
        duration_layout.add_widget(self.duration_input)
        form_grid.add_widget(duration_layout)
        
        # Notes
        notes_layout = BoxLayout(orientation='vertical', size_hint=(1, None), height=dp(100))
        self.notes_label = Label(
            text=tr("notes_optional"),
            font_size=dp(16),
            color=(0.3, 0.3, 0.3, 1),
            halign='left',
            size_hint=(1, None),
            height=dp(25)
        )
        self.notes_label.bind(size=self.notes_label.setter('text_size'))
        
        self.notes_input = TextInput(
            hint_text=tr("special_instructions"),
            multiline=True,
            size_hint=(1, None),
            height=dp(75),
            padding=[dp(10), dp(10)],
            font_size=dp(16)
        )
        notes_layout.add_widget(self.notes_label)
        notes_layout.add_widget(self.notes_input)
        form_grid.add_widget(notes_layout)
        
        # Buttons
        button_layout = BoxLayout(size_hint=(1, None), height=dp(50), spacing=dp(20))
        
        self.cancel_btn = RoundedButton(
            text=tr("cancel"),
            size_hint=(0.5, 1),
            bg_color=(0.9, 0.3, 0.3, 1),  # Red color
            color=(1, 1, 1, 1)  # White text
        )
        self.cancel_btn.bind(on_release=self.hide_form)
        
        self.save_btn = RoundedButton(
            text=tr("save"),
            size_hint=(0.5, 1),
            bg_color=(0.2, 0.7, 0.3, 1)  # Green
        )
        self.save_btn.bind(on_release=self.save_reminder)
        
        button_layout.add_widget(self.cancel_btn)
        button_layout.add_widget(self.save_btn)
        form_grid.add_widget(button_layout)
        
        # Add a button to ask AI for help
        ai_button_layout = BoxLayout(size_hint=(1, None), height=dp(60), padding=[0, dp(10)])
        
        self.ai_help_btn = RoundedButton(
            text=tr('ask_ai_assistant'),
            size_hint=(1, 1),
            bg_color=(0.5, 0.3, 0.9, 1)  # Purple
        )
        self.ai_help_btn.bind(on_release=self.ask_ai_about_medication)
        # Initially disable the button since the form is not visible yet
        self.ai_help_btn.disabled = True
        
        ai_button_layout.add_widget(self.ai_help_btn)
        form_grid.add_widget(ai_button_layout)
        
        self.form_container.add_widget(form_grid)
        self.main_layout.add_widget(self.form_container)
        
        # Create a dropdown for frequency selection
        self.frequency_dropdown = DropDown(
            auto_width=False,
            width=dp(200),
            max_height=dp(250)  # Limit the height to make it more compact
        )
        
        # Frequency options
        frequencies = [
            'Once daily', 
            'Twice daily', 
            'Three times daily', 
            'Four times daily',
            'Every 1 hour',
            'Every 2 hours',
            'Every 3 hours',
            'Every 4 hours',
            'Every 5 hours',
            'Every 6 hours', 
            'Every 8 hours',
            'Every 10 hours', 
            'Every 12 hours'
        ]
        
        for freq in frequencies:
            btn = RoundedButton(
                text=freq,
                size_hint_y=None,
                height=dp(50),
                bg_color=(0xfd/255, 0xde/255, 0x86/255, 1),  # #fdde86 (yellow)
                text_color=(0, 0, 0, 1),  # Pure black text for maximum contrast
                color=(0, 0, 0, 1)  # Pure black text for maximum contrast
            )
            
            # Set the button's text as the dropdown selection
            btn.bind(on_release=lambda btn: self.frequency_dropdown.select(btn.text))
            self.frequency_dropdown.add_widget(btn)
        
        # Bind the dropdown selection to update the button text
        self.frequency_dropdown.bind(on_select=lambda instance, x: setattr(self.frequency_button, 'text', x))
        
        # Load reminders on startup
        Clock.schedule_once(self.load_reminders, 0.1)
        
        # Now that all UI elements are created, we can call update_theme
        self.update_theme()
        
        # Bind to language changes
        self.language_manager.bind(current_language=self._update_language)
    
    def _update_language(self, *args):
        """Update all UI elements with the current language"""
        # Update all text elements
        self.title_label.text = tr('antibiotic_reminder')
        self.add_text.text = tr('add')
        self.form_title.text = tr('add_new_antibiotic_reminder') if self.is_adding_reminder else tr('edit_antibiotic_reminder')
        self.name_label.text = tr('medication_name')
        self.dosage_label.text = tr('dosage')
        self.frequency_label.text = tr('frequency')
        self.duration_label.text = tr('duration_days')
        self.notes_label.text = tr('notes_optional')
        self.cancel_btn.text = tr('cancel')
        self.save_btn.text = tr('save')
        self.ai_help_btn.text = tr('ask_ai_assistant')
        self.no_reminders_label.text = tr('no_reminders_yet')
        
        # Update input hints
        self.name_input.hint_text = tr('enter_medication_name')
        self.dosage_input.hint_text = tr('enter_dosage')
        if self.frequency_button.text == 'Select frequency':
            self.frequency_button.text = tr('select_frequency')
        self.duration_input.hint_text = tr('enter_duration')
        self.notes_input.hint_text = tr('special_instructions')
        
        # Reload reminders to update their text
        self.load_reminders()
    
    def _update_form_bg(self, *args):
        """Update form background rectangle"""
        self.form_bg.pos = self.form_container.pos
        self.form_bg.size = self.form_container.size
    
    def toggle_frequency_options(self, instance):
        """Show frequency options dropdown"""
        # Only show dropdown if form is visible
        if self.form_visible:
            # First make the entire screen background dark with a semi-transparent overlay
            with self.main_layout.canvas.before:
                Color(0, 0, 0, 0.7)  # Dark semi-transparent overlay
                self.overlay_rect = Rectangle(pos=self.main_layout.pos, size=self.main_layout.size)
                self.main_layout.bind(pos=self._update_overlay, size=self._update_overlay)
            
            # Hide all children of the main layout except form container
            for child in self.main_layout.children:
                if child != self.form_container:
                    child.opacity = 0
            
            # Hide all elements in the form except the frequency button and its parent
            for child in self.form_container.walk(restrict=True):
                if child == self.frequency_button or child == self.frequency_button.parent:
                    continue
                child.opacity = 0
            
            # Calculate better position for dropdown - center in the screen
            window_width, window_height = Window.size
            
            # Create a custom dropdown container in the middle of the screen
            dropdown_width = min(dp(300), window_width * 0.8)
            dropdown_height = min(dp(300), window_height * 0.6)
            
            # Position the dropdown in the center of the screen
            dropdown_x = (window_width - dropdown_width) / 2
            dropdown_y = (window_height - dropdown_height) / 2
            
            # Set dropdown properties with custom style
            self.frequency_dropdown.width = dropdown_width
            self.frequency_dropdown.max_height = dropdown_height
            
            # Clear any previous widgets to rebuild the dropdown with shadow
            self.frequency_dropdown.clear_widgets()
            
            # Create a container for the dropdown with shadow
            dropdown_container = FloatLayout(
                size_hint=(None, None),
                size=(dropdown_width, dropdown_height),
                pos=(dropdown_x, dropdown_y)
            )
            
            # Add shadow effects to the container
            with dropdown_container.canvas.before:
                # Shadow layers for depth effect
                Color(0, 0, 0, 0.3)  # Outer shadow
                RoundedRectangle(
                    pos=(dropdown_x + dp(5), dropdown_y - dp(5)), 
                    size=(dropdown_width, dropdown_height),
                    radius=[dp(10)]
                )
                
                Color(0, 0, 0, 0.4)  # Middle shadow
                RoundedRectangle(
                    pos=(dropdown_x + dp(3), dropdown_y - dp(3)), 
                    size=(dropdown_width, dropdown_height),
                    radius=[dp(10)]
                )
                
                # Background color based on theme
                if self.theme_manager.is_dark_mode:
                    Color(0x22/255, 0x22/255, 0x26/255, 1)  # Dark gray - #222226
                else:
                    Color(0.95, 0.95, 0.97, 1)  # Light background
                
                # Main background
                RoundedRectangle(
                    pos=(dropdown_x, dropdown_y),
                    size=(dropdown_width, dropdown_height),
                    radius=[dp(10)]
                )
            
            # Create a ScrollView for the options
            scroll_view = ScrollView(
                size_hint=(None, None),
                size=(dropdown_width - dp(10), dropdown_height - dp(10)),
                pos=(dropdown_x + dp(5), dropdown_y + dp(5)),
            )
            
            # Create a vertical layout for the options
            options_layout = GridLayout(
                cols=1,
                spacing=dp(2),
                size_hint_y=None
            )
            options_layout.bind(minimum_height=options_layout.setter('height'))
            
            # Add title
            title_label = Label(
                text="Select Frequency",
                size_hint_y=None,
                height=dp(40),
                font_size=dp(16),
                bold=True,
                color=(0.9, 0.9, 0.9, 1) if self.theme_manager.is_dark_mode else (0.1, 0.1, 0.1, 1)
            )
            options_layout.add_widget(title_label)
            
            # Frequency options
            frequencies = [
                'Once daily', 
                'Twice daily', 
                'Three times daily', 
                'Four times daily',
                'Every 1 hour',
                'Every 2 hours',
                'Every 3 hours',
                'Every 4 hours',
                'Every 5 hours',
                'Every 6 hours', 
                'Every 8 hours',
                'Every 10 hours', 
                'Every 12 hours'
            ]
            
            # Add all frequency options
            for freq in frequencies:
                btn = RoundedButton(
                    text=freq,
                    size_hint_y=None,
                    height=dp(50),
                    bg_color=(0x2a/255, 0x2a/255, 0x2e/255, 1) if self.theme_manager.is_dark_mode else (0xfd/255, 0xde/255, 0x86/255, 1),
                    text_color=(0.9, 0.9, 0.9, 1) if self.theme_manager.is_dark_mode else (0, 0, 0, 1)
                )
                
                # When clicked, update the frequency button text and dismiss
                def create_callback(text):
                    def callback(instance):
                        self.frequency_button.text = text
                        self._on_dropdown_dismiss(None)
                    return callback
                
                btn.bind(on_release=create_callback(freq))
                options_layout.add_widget(btn)
            
            # Add cancel button at the bottom
            cancel_btn = RoundedButton(
                text="Cancel",
                size_hint_y=None,
                height=dp(50),
                bg_color=(0.7, 0.3, 0.3, 1),
                text_color=(1, 1, 1, 1)
            )
            cancel_btn.bind(on_release=lambda x: self._on_dropdown_dismiss(None))
            options_layout.add_widget(cancel_btn)
            
            # Add everything to the container
            scroll_view.add_widget(options_layout)
            self.main_layout.add_widget(dropdown_container)
            self.main_layout.add_widget(scroll_view)
            
            # Store references to remove them later
            self.dropdown_container = dropdown_container
            self.dropdown_scroll = scroll_view
    
    def _update_overlay(self, instance, value):
        """Update overlay rectangle position and size"""
        if hasattr(self, 'overlay_rect'):
            self.overlay_rect.pos = instance.pos
            self.overlay_rect.size = instance.size
    
    def _on_dropdown_dismiss(self, instance):
        """Callback when dropdown is dismissed to restore content"""
        # Remove the dark overlay
        if hasattr(self, 'overlay_rect'):
            self.main_layout.canvas.before.remove(self.overlay_rect)
            delattr(self, 'overlay_rect')
        
        # Remove custom dropdown components if they exist
        if hasattr(self, 'dropdown_container'):
            self.main_layout.remove_widget(self.dropdown_container)
            delattr(self, 'dropdown_container')
            
        if hasattr(self, 'dropdown_scroll'):
            self.main_layout.remove_widget(self.dropdown_scroll)
            delattr(self, 'dropdown_scroll')
        
        # Restore visibility of all main layout children
        for child in self.main_layout.children:
            child.opacity = 1
        
        # Restore visibility of all form elements
        for child in self.form_container.walk(restrict=True):
            child.opacity = 1
    
    def load_reminders(self, dt=None):
        """Load reminders from the reminder manager"""
        if not self.reminder_manager:
            return
        
        # Store existing reminder cards by ID
        existing_cards = {}
        for child in list(self.reminders_layout.children):
            if isinstance(child, ReminderCard) and child.reminder_id:
                existing_cards[child.reminder_id] = child
                self.reminders_layout.remove_widget(child)  # Remove but don't destroy
        
        # Get active reminders
        reminders = self.reminder_manager.get_active_reminders()
        
        # Show or hide the no reminders message
        self.no_reminders_label.opacity = 1 if not reminders else 0
        
        # Track processed reminders and ensure no duplicates
        processed_ids = set()
        seen_reminder_keys = set()  # Track unique medication+dosage+frequency combinations
        
        # Add reminders, reusing existing cards when possible and avoiding duplicates
        for reminder in reminders:
            reminder_id = reminder.get('id', '')
            if not reminder_id:
                continue
                
            # Create a unique key based on medication name, dosage, and frequency
            reminder_key = (
                reminder.get('medication_name', ''),
                reminder.get('dosage', ''),
                reminder.get('frequency', '')
            )
            
            # Skip if we've already processed this ID or it's a duplicate medication
            if reminder_id in processed_ids or reminder_key in seen_reminder_keys:
                continue
                
            processed_ids.add(reminder_id)
            seen_reminder_keys.add(reminder_key)
            
            if reminder_id in existing_cards:
                # Reuse existing card with preserved state
                card = existing_cards[reminder_id]
                # Update card data while preserving state
                if hasattr(card, 'update_card_data'):
                    card.update_card_data(reminder)
                self.reminders_layout.add_widget(card)
            else:
                # Create a new card
                card = ReminderCard(reminder)
                self.reminders_layout.add_widget(card)
        
        # Properly clean up cards for reminders that no longer exist
        for reminder_id, card in existing_cards.items():
            if reminder_id not in processed_ids:
                # This card's reminder no longer exists, so we don't add it back
                pass  # No need to do anything, we already removed it from the layout
    
    def show_add_reminder(self, instance):
        """Show the add reminder form"""
        self.is_adding_reminder = True
        self.editing_reminder_id = ''
        self.form_title.text = tr("add_new_antibiotic_reminder")
        self.save_btn.text = tr("save")
        
        # Clear form fields
        self.name_input.text = ''
        self.dosage_input.text = ''
        self.frequency_button.text = tr('select_frequency')
        self.duration_input.text = ''
        self.notes_input.text = ''
        
        # Show form, hide reminders
        self.form_container.opacity = 1
        self.form_visible = True
        self.scroll_view.opacity = 0
        self.no_reminders_label.opacity = 0

        # Enable AI help button
        if hasattr(self, 'ai_help_btn'):
            self.ai_help_btn.disabled = False
    
    def show_edit_reminder(self, reminder_id):
        """Show the edit reminder form"""
        if not self.reminder_manager:
            return
        
        reminder = self.reminder_manager.get_reminder(reminder_id)
        if not reminder:
            return
        
        self.is_adding_reminder = False
        self.editing_reminder_id = reminder_id
        self.form_title.text = tr("edit_antibiotic_reminder")
        self.save_btn.text = tr("update")
        
        # Fill form fields with reminder data
        self.name_input.text = reminder.get('medication_name', '')
        self.dosage_input.text = reminder.get('dosage', '')
        self.frequency_button.text = reminder.get('frequency', tr('select_frequency'))
        self.duration_input.text = str(reminder.get('duration', ''))
        self.notes_input.text = reminder.get('notes', '')
        
        # Show form, hide reminders
        self.form_container.opacity = 1
        self.form_visible = True
        self.scroll_view.opacity = 0
        self.no_reminders_label.opacity = 0

        # Enable AI help button
        if hasattr(self, 'ai_help_btn'):
            self.ai_help_btn.disabled = False
    
    def hide_form(self, instance=None):
        """Hide the add/edit reminder form"""
        # Hide form, show reminders
        self.form_container.opacity = 0
        self.form_visible = False
        self.scroll_view.opacity = 1
        
        # Disable AI help button
        if hasattr(self, 'ai_help_btn'):
            self.ai_help_btn.disabled = True
        
        # Show no reminders message if needed
        if not self.reminders_layout.children:
            self.no_reminders_label.opacity = 1
    
    def save_reminder(self, instance):
        """Save or update a medication reminder"""
        if not self.reminder_manager:
            print("No reminder manager available")
            return
            
        # Validate form input
        medication_name = self.name_input.text.strip()
        app = App.get_running_app()
                
        if not medication_name:
            self.show_error_message(tr("Medication name is required"))
            return
            
        # Get other form values
        dosage = self.dosage_input.text.strip()
        frequency = self.frequency_button.text
        
        if frequency == tr('select_frequency'):
            self.show_error_message(tr("Please select a frequency"))
            return
        
        try:
            duration = int(self.duration_input.text.strip()) if self.duration_input.text.strip() else 0
        except ValueError:
            self.show_error_message(tr("Duration must be a number"))
            return
            
        notes = self.notes_input.text.strip()
        
        # Check for duplicates by comparing name, dosage, and frequency
        if self.is_adding_reminder:
            active_reminders = self.reminder_manager.get_active_reminders()
            for reminder in active_reminders:
                if (reminder.get('medication_name') == medication_name and
                    reminder.get('dosage') == dosage and
                    reminder.get('frequency') == frequency):
                    # This is a duplicate - show a message
                    self.show_error_message(tr("This reminder already exists"))
                    return
        
        # Save or update the reminder
        if self.is_adding_reminder:
            # Add new reminder
            self.reminder_manager.add_reminder(
                medication_name=medication_name,
                dosage=dosage,
                frequency=frequency,
                duration=duration,
                notes=notes,
                doses_taken=0  # Initialize with 0 doses taken
            )
        else:
            # Get current doses taken from existing reminder
            current_reminder = self.reminder_manager.get_reminder(self.editing_reminder_id)
            doses_taken = current_reminder.get('doses_taken', 0) if current_reminder else 0
            
            # Update existing reminder
            self.reminder_manager.update_reminder(
                reminder_id=self.editing_reminder_id,
                medication_name=medication_name,
                dosage=dosage,
                frequency=frequency,
                duration=duration,
                notes=notes,
                doses_taken=doses_taken  # Preserve existing doses taken count
            )
            
        # Hide form and refresh reminders
        self.hide_form()
        self.load_reminders()
    
    def delete_reminder(self, reminder_id):
        """Delete a reminder"""
        if not self.reminder_manager:
            return
        
        self.reminder_manager.delete_reminder(reminder_id)
        self.load_reminders()
    
    def ask_ai_about_medication(self, instance):
        """Open the Voice/AI screen with context about the current medication"""
        # Safety check: only proceed if the form is visible
        if not self.form_visible:
            print("Form not visible, ignoring AI assistant request")
            return
            
        from kivy.app import App
        app = App.get_running_app()
        
        # Get medication name from form
        medication_name = self.name_input.text.strip()
        
        print(f"Opening AI assistant with medication: {medication_name if medication_name else 'no specific medication'}")
            
        try:
            # Explicitly create a new VoiceScreen instance
            voice_screen = VoiceScreen(name='voice')
            
            # Set the medication context only if provided
            if medication_name:
                voice_screen.set_medication_context(medication_name)
            
            # Get the screen manager
            sm = app.root
            
            # Check if voice screen already exists and replace it
            if 'voice' in sm.screen_names:
                sm.remove_widget(sm.get_screen('voice'))
            
            # Add the new voice screen
            sm.add_widget(voice_screen)
            
            # Hide the form before navigating
            self.hide_form()
            
            # Navigate to the voice screen
            print("Switching to voice screen")
            sm.current = 'voice'
            
        except Exception as e:
            import traceback
            print(f"Error navigating to voice screen: {e}")
            traceback.print_exc()
            
            # Show error message to user
            self.status_label = Label(
                text="Could not open AI assistant. Please try again.",
                font_size=dp(14),
                color=(0.9, 0.3, 0.3, 1),  # Red text
                size_hint=(1, None),
                height=dp(30),
                pos_hint={'center_x': 0.5, 'center_y': 0.9}
            )
            # Find the form grid and add the message
            for child in self.form_container.children:
                if isinstance(child, GridLayout):
                    child.add_widget(self.status_label, 1)
                    # Remove after 3 seconds
                    Clock.schedule_once(lambda dt: child.remove_widget(self.status_label), 3)
                    break
    
    def update_theme(self, *args):
        """Update colors based on current theme"""
        # Call parent's update_theme
        super(ReminderScreen, self).update_theme(*args)
        
        # Get theme colors
        colors = self.theme_manager.get_colors()
        is_dark = self.theme_manager.is_dark_mode
        
        # Update UI elements specific to this screen
        
        # Title label
        if hasattr(self, 'title_label'):
            self.title_label.color = colors['text']
            
        # Form background
        if hasattr(self, 'form_bg_color'):
            self.form_bg_color.rgba = colors['background']
            
        # Update form labels
        for name in ['name_label', 'dosage_label', 'frequency_label', 'duration_label', 'notes_label']:
            if hasattr(self, name):
                getattr(self, name).color = colors['text']
                
        # Update form inputs
        for name in ['name_input', 'dosage_input', 'duration_input', 'notes_input']:
            if hasattr(self, name):
                input_elem = getattr(self, name)
                input_elem.background_color = colors['input_bg']
                input_elem.foreground_color = colors['text']
                input_elem.cursor_color = colors['primary']
                
        # Update frequency button - always use dark gray in dark mode and yellow in light mode
        if hasattr(self, 'frequency_button'):
            if is_dark:
                if hasattr(self.frequency_button, 'set_bg_color'):
                    self.frequency_button.set_bg_color((0x2a/255, 0x2a/255, 0x2e/255, 1))  # Dark gray in dark mode
                else:
                    self.frequency_button.bg_color = (0x2a/255, 0x2a/255, 0x2e/255, 1)  # Dark gray in dark mode
                self.frequency_button.color = (0.9, 0.9, 0.9, 1)  # Light text in dark mode
            else:
                if hasattr(self.frequency_button, 'set_bg_color'):
                    self.frequency_button.set_bg_color((0xfd/255, 0xde/255, 0x86/255, 1))  # Yellow in light mode
                else:
                    self.frequency_button.bg_color = (0xfd/255, 0xde/255, 0x86/255, 1)  # Yellow in light mode
                self.frequency_button.color = (0.1, 0.1, 0.1, 1)  # Dark text in light mode
        
        # Update buttons
        if hasattr(self, 'cancel_btn'):
            self.cancel_btn.color = (1, 1, 1, 1)  # White text
            # Keep red color but adjust for dark mode
            if is_dark:
                if hasattr(self.cancel_btn, 'set_bg_color'):
                    self.cancel_btn.set_bg_color((0.7, 0.2, 0.2, 1))  # Darker red for dark mode
                else:
                    self.cancel_btn.bg_color = (0.7, 0.2, 0.2, 1)  # Darker red for dark mode
            else:
                if hasattr(self.cancel_btn, 'set_bg_color'):
                    self.cancel_btn.set_bg_color((0.9, 0.3, 0.3, 1))  # Original red
                else:
                    self.cancel_btn.bg_color = (0.9, 0.3, 0.3, 1)  # Original red
            
        if hasattr(self, 'save_btn'):
            # Keep green but adjust for dark mode
            if is_dark:
                if hasattr(self.save_btn, 'set_bg_color'):
                    self.save_btn.set_bg_color((0.1, 0.5, 0.2, 1))  # Darker green
                else:
                    self.save_btn.bg_color = (0.1, 0.5, 0.2, 1)  # Darker green
            else:
                if hasattr(self.save_btn, 'set_bg_color'):
                    self.save_btn.set_bg_color((0.2, 0.7, 0.3, 1))  # Original green
                else:
                    self.save_btn.bg_color = (0.2, 0.7, 0.3, 1)  # Original green
            self.save_btn.color = (1, 1, 1, 1)  # White text
            
        if hasattr(self, 'ai_help_btn'):
            # Adjust purple for dark mode
            if is_dark:
                if hasattr(self.ai_help_btn, 'set_bg_color'):
                    self.ai_help_btn.set_bg_color((0.3, 0.2, 0.6, 1))  # Darker purple
                else:
                    self.ai_help_btn.bg_color = (0.3, 0.2, 0.6, 1)  # Darker purple
            else:
                if hasattr(self.ai_help_btn, 'set_bg_color'):
                    self.ai_help_btn.set_bg_color((0.5, 0.3, 0.9, 1))  # Original purple
                else:
                    self.ai_help_btn.bg_color = (0.5, 0.3, 0.9, 1)  # Original purple
            self.ai_help_btn.color = (1, 1, 1, 1)  # White text
            
        # No reminders label
        if hasattr(self, 'no_reminders_label'):
            self.no_reminders_label.color = colors['text_secondary'] if 'text_secondary' in colors else (0.6, 0.6, 0.6, 1)
            
        # Update add button and text
        if hasattr(self, 'circle_plus_btn'):
            # Keep green but adjust for dark mode
            if is_dark:
                # RoundButton uses different properties than RoundedButton
                if hasattr(self.circle_plus_btn, 'set_bg_color'):
                    self.circle_plus_btn.set_bg_color((0.1, 0.5, 0.2, 1))  # Darker green
                else:
                    self.circle_plus_btn.bg_color = (0.1, 0.5, 0.2, 1)  # Darker green
            else:
                if hasattr(self.circle_plus_btn, 'set_bg_color'):
                    self.circle_plus_btn.set_bg_color((0.2, 0.7, 0.3, 1))  # Original green
                else:
                    self.circle_plus_btn.bg_color = (0.2, 0.7, 0.3, 1)  # Original green
            
            # Different button types might use different property names
            if hasattr(self.circle_plus_btn, 'fg_color'):
                self.circle_plus_btn.fg_color = (1, 1, 1, 1)  # Always white text
                
        if hasattr(self, 'add_text'):
            if is_dark:
                self.add_text.color = (0.1, 0.5, 0.2, 1)  # Darker green
            else:
                self.add_text.color = (0.2, 0.7, 0.3, 1)  # Original green
                
        # Update all reminder cards
        for child in self.reminders_layout.children:
            if isinstance(child, ReminderCard) and hasattr(child, 'update_theme'):
                child.update_theme()
    
    def _on_theme_change(self, *args):
        self.update_theme()
    
    def delete_all_reminders(self):
        """Delete all reminders"""
        if not self.reminder_manager:
            return
            
        # Get all reminders
        reminders = self.reminder_manager.get_active_reminders()
        
        # Delete each reminder
        for reminder in reminders:
            reminder_id = reminder.get('id', '')
            if reminder_id:
                self.reminder_manager.delete_reminder(reminder_id)
        
        # Refresh the list
        self.load_reminders()
    
    def show_error_message(self, message):
        """Display an error message in the form"""
        # Create an error label that will fade out after a few seconds
        error_label = Label(
            text=message,
            font_size=dp(16),
            color=(0.9, 0.3, 0.3, 1),  # Red text
            size_hint=(1, None),
            height=dp(30),
            pos_hint={'center_x': 0.5, 'top': 0.95}
        )
        
        # Add it to the form container if visible
        if self.form_visible and hasattr(self, 'form_container'):
            self.form_container.add_widget(error_label)
            
            # Schedule removal after 3 seconds
            def remove_label(dt):
                self.form_container.remove_widget(error_label)
            
            Clock.schedule_once(remove_label, 3)

# Camera Screen - Shows the bars
class MediScanScreen(BaseScreen):
    def __init__(self, **kwargs):
        # First initialize the parent BaseScreen
        try:
            super(MediScanScreen, self).__init__(**kwargs)
        except Exception as e:
            print(f"Error initializing MediScanScreen: {e}")
            return
            
        try:
            # Add title with improved styling
            title = Label(
                text='MediScan',
                font_size=dp(24),
                bold=True,
                color=(0.2, 0.4, 0.8, 1),  # Blue text
                pos_hint={'center_x': 0.5, 'top': 0.95}
            )
            self.main_layout.add_widget(title)
            
            # Add camera content
            content = Label(
                text='This feature will allow you to scan and identify medications using your camera.\n\nComing in the next update!',
                font_size=dp(18),
                color=(0.3, 0.3, 0.3, 1),
                halign='center',
                pos_hint={'center_x': 0.5, 'center_y': 0.5}
            )
            self.main_layout.add_widget(content)
            
            # Add camera icon in a circular container for visual appeal
            icon_container = FloatLayout(
                size_hint=(None, None),
                size=(dp(120), dp(120)),
                pos_hint={'center_x': 0.5, 'center_y': 0.7}
            )
            
            # Add circular background
            with icon_container.canvas.before:
                Color(0.95, 0.95, 1, 1)  # Light blue background
                Ellipse(pos=(0, 0), size=(dp(120), dp(120)))
            
            # Add camera icon
            try:
                camera_icon = Image(
                    source='icons/x-ray.png',  # Changed from camera.png to x-ray.png
                    size_hint=(None, None),
                    size=(dp(80), dp(80)),
                    pos_hint={'center_x': 0.5, 'center_y': 0.5}
                )
                icon_container.add_widget(camera_icon)
            except Exception as e:
                print(f"Error loading camera icon: {e}")
                # Add a fallback label if image fails to load
                fallback = Label(text="📷", font_size=dp(40))
                icon_container.add_widget(fallback)
                
            self.main_layout.add_widget(icon_container)
            
            # Add a coming soon button
            coming_soon = Button(
                text="Coming Soon",
                size_hint=(0.5, None),
                height=dp(50),
                pos_hint={'center_x': 0.5, 'center_y': 0.3},
                background_normal='',
                background_color=(0.7, 0.7, 0.7, 1),
                color=(1, 1, 1, 1)
            )
            self.main_layout.add_widget(coming_soon)
            
        except Exception as e:
            # If anything fails, add an error message instead of crashing
            print(f"Error setting up MediScanScreen: {e}")
            error_label = Label(
                text=f"Sorry, there was an error loading this screen.\nPlease try again later.",
                font_size=dp(18),
                color=(0.8, 0.3, 0.3, 1),  # Red text
                halign='center',
                pos_hint={'center_x': 0.5, 'center_y': 0.5}
            )
            self.main_layout.add_widget(error_label)

# Voice Assistant Screen with AI integration
from kivy.animation import Animation
from kivy.uix.behaviors import ToggleButtonBehavior
from kivy.core.window import Window
from kivy.clock import Clock
from datetime import datetime
import threading

# Try to import the full-featured AI assistant first
try:
    from ai_assistant import AIAssistant
    HAS_FULL_AI = True
except ImportError:
    HAS_FULL_AI = False
    
# Try to import the simplified AI assistant as fallback
try:
    from simple_ai_assistant import SimpleAIAssistant
    HAS_SIMPLE_AI = True
except ImportError:
    HAS_SIMPLE_AI = False

class PulsingMicButton(ToggleButtonBehavior, BoxLayout):
    def __init__(self, **kwargs):
        super(PulsingMicButton, self).__init__(**kwargs)
        self.orientation = 'vertical'
        self.size_hint = (None, None)
        self.size = (dp(80), dp(120))
        self.pos_hint = {'center_x': 0.5, 'center_y': 0.15}  # Moved up from 0.3 to 0.15
        self.spacing = dp(5)
        
        # Create the microphone icon container
        self.icon_container = FloatLayout(
            size_hint=(None, None),
            size=(dp(70), dp(70)),  # Reduced from (100, 100)
            pos_hint={'center_x': 0.5, 'top': 1}
        )
        
        # Add circular background
        with self.icon_container.canvas.before:
            Color(0.95, 0.95, 0.95, 1)  # Light gray
            self.bg_circle = Ellipse(
                pos=(self.icon_container.center_x - dp(35), self.icon_container.center_y - dp(35)),  # Adjusted for new size
                size=(dp(70), dp(70))  # Reduced from (100, 100)
            )
        self.icon_container.bind(pos=self._update_ellipse, size=self._update_ellipse)
        
        # Add microphone icon
        self.mic_icon = Image(
            source='icons/microphone.png',
            size_hint=(None, None),
            size=(dp(40), dp(40)),  # Reduced from (60, 60)
            pos_hint={'center_x': 0.5, 'center_y': 0.5}
        )
        self.icon_container.add_widget(self.mic_icon)
        self.add_widget(self.icon_container)
        
        # Add label
        self.label = Label(
            text='Tap to speak',
            font_size=dp(14),  # Reduced from 16
            color=(0.3, 0.3, 0.3, 1),
            bold=True,
            size_hint=(1, None),
            height=dp(25)  # Reduced from 30
        )
        self.add_widget(self.label)
        
        # Set initial state
        self.pulsing_animation = None
        self.state = 'normal'
    
    def _update_ellipse(self, *args):
        self.bg_circle.pos = (
            self.icon_container.x + (self.icon_container.width - dp(70)) / 2,
            self.icon_container.y + (self.icon_container.height - dp(70)) / 2
        )
    
    def on_state(self, instance, value):
        if value == 'down':
            # Start pulsing animation
            self._start_pulsing()
            self.label.text = 'Listening...'
            self.label.color = (0.9, 0.3, 0.3, 1)  # Red text
        else:
            # Stop pulsing animation
            self._stop_pulsing()
            self.label.text = 'Tap to speak'
            self.label.color = (0.3, 0.3, 0.3, 1)  # Gray text
    
    def _start_pulsing(self):
        # Create pulsing animation for the background circle
        scale_up = Animation(
            size=(dp(75), dp(75)), 
            pos=(
                self.icon_container.center_x - dp(37.5), 
                self.icon_container.center_y - dp(37.5)
            ), 
            duration=0.7
        )
        scale_down = Animation(
            size=(dp(70), dp(70)), 
            pos=(
                self.icon_container.center_x - dp(35), 
                self.icon_container.center_y - dp(35)
            ), 
            duration=0.7
        )
        self.pulsing_animation = scale_up + scale_down
        self.pulsing_animation.repeat = True
        self.pulsing_animation.start(self.bg_circle)
        
        # Change background color to indicate recording
        with self.icon_container.canvas.before:
            Color(0.9, 0.3, 0.3, 0.2)  # Light red
            self.bg_circle = Ellipse(
                pos=(self.icon_container.center_x - dp(35), self.icon_container.center_y - dp(35)), 
                size=(dp(70), dp(70))
            )
    
    def _stop_pulsing(self):
        if self.pulsing_animation:
            self.pulsing_animation.cancel(self.bg_circle)
            self.pulsing_animation = None
        
        # Reset background color
        with self.icon_container.canvas.before:
            Color(0.95, 0.95, 0.95, 1)  # Light gray
            self.bg_circle = Ellipse(
                pos=(self.icon_container.center_x - dp(35), self.icon_container.center_y - dp(35)), 
                size=(dp(70), dp(70))
            )

class ChatBubble(BoxLayout):
    def __init__(self, message, is_user=False, **kwargs):
        super(ChatBubble, self).__init__(**kwargs)
        self.orientation = 'horizontal'
        self.size_hint_y = None
        self.padding = [dp(10), dp(5)]
        self.spacing = dp(10)
        self.is_user = is_user
        self.message = message
        self.theme_manager = ThemeManager()
        
        # Calculate needed height based on text length
        text_width = Window.width * 0.7  # 70% of screen width for text
        self.label = Label(
            text=message,
            size_hint_x=None,
            width=text_width,
            text_size=(text_width, None),
            halign='left',
            valign='middle',
            padding=[dp(15), dp(10)]
        )
        self.label.bind(texture_size=self._update_size)
        
        # Set bubble style based on user or ai
        self.bubble = BoxLayout(
            size_hint=(0.8, 1),
            pos_hint={'right': 1} if is_user else {'x': 0}
        )
        
        with self.bubble.canvas.before:
            # Initial colors will be updated in update_theme
            self.bubble_color = Color(*(0.2, 0.6, 0.9, 1) if is_user else (0.95, 0.95, 0.95, 1))
            self.rect = RoundedRectangle(size=self.bubble.size, pos=self.bubble.pos, radius=[dp(15)])
        self.bubble.bind(size=self._update_rect, pos=self._update_rect)
        
        self.bubble.add_widget(self.label)
        
        # Add to main layout with correct alignment
        if is_user:
            self.add_widget(Widget(size_hint_x=0.2))  # Spacer on left for user messages
            self.add_widget(self.bubble)
        else:
            self.add_widget(self.bubble)
            self.add_widget(Widget(size_hint_x=0.2))  # Spacer on right for AI messages
            
        # Update colors based on current theme
        self.update_theme(self.theme_manager.is_dark_mode)
    
    def _update_size(self, instance, value):
        # Update height based on text content
        self.height = value[1] + dp(20)  # Text height + padding
    
    def _update_rect(self, instance, value):
        self.rect.size = instance.size
        self.rect.pos = instance.pos
        
    def update_theme(self, is_dark):
        """Update colors based on theme"""
        if self.is_user:
            # User bubble - blue in both themes but darker in dark mode
            bubble_color = (0.1, 0.4, 0.7, 1) if is_dark else (0.2, 0.6, 0.9, 1)
            text_color = (1, 1, 1, 1)  # Always white text for user bubbles
        else:
            # AI bubble - dark gray in dark mode, light gray in light mode
            bubble_color = (0.2, 0.2, 0.2, 1) if is_dark else (0.95, 0.95, 0.95, 1)
            text_color = (0.9, 0.9, 0.9, 1) if is_dark else (0.1, 0.1, 0.1, 1)
        
        self.bubble_color.rgba = bubble_color
        self.label.color = text_color

class VoiceScreen(BaseScreen):
    def __init__(self, **kwargs):
        super(VoiceScreen, self).__init__(auto_update_theme=False, **kwargs)
        self.language_manager = LanguageManager()
        
        # Initialize AI assistant with proper fallback mechanisms
        self.ai_assistant = None
        
        # Try to initialize AI assistant
        try:
            # First try to use the full AI assistant with API
            from ai_assistant import AIAssistant
            
            # Check if the API key is valid
            api_key_file = 'openai_api_key.txt'
            if os.path.exists(api_key_file):
                with open(api_key_file, 'r') as f:
                    api_key = f.read().strip()
                    if api_key and 'YOUR_API_KEY' not in api_key:
                        self.ai_assistant = AIAssistant(api_key)
        except Exception as e:
            print(f"Error initializing AIAssistant: {e}")
            
        # If full AI assistant failed, use the simple version
        if not self.ai_assistant:
            try:
                from simple_ai_assistant import SimpleAIAssistant
                self.ai_assistant = SimpleAIAssistant()
                
                # Set up a direct binding to detect when the reminder event changes
                if hasattr(self.ai_assistant, 'create_reminder_event'):
                    print("Setting up reminder event binding")
                    self.ai_assistant.bind(create_reminder_event=self._on_reminder_event_change)
                    
            except Exception as e:
                print(f"Error initializing SimpleAIAssistant: {e}")
                self.ai_assistant = None
        
        # Track if we're currently processing voice input
        self.is_listening = False
        self.is_processing = False
        self.medication_context = None
        
        # Add title with subtitle
        title_box = BoxLayout(
            orientation='vertical',
            size_hint=(1, None),
            height=dp(60),
            pos_hint={'center_x': 0.5, 'top': 0.98},
            spacing=dp(2)
        )
        
        self.title_label = Label(
            text=tr('medical_assistant'),
            font_size=dp(24),
            bold=True,
            color=(0.2, 0.4, 0.8, 1),  # Blue
            size_hint=(1, None),
            height=dp(30)
        )
        
        self.subtitle_label = Label(
            text=tr('ask_about_medication'),
            font_size=dp(14),
            italic=True,
            color=(0.5, 0.5, 0.5, 1),  # Gray
            size_hint=(1, None),
            height=dp(20)
        )
        
        title_box.add_widget(self.title_label)
        title_box.add_widget(self.subtitle_label)
        self.main_layout.add_widget(title_box)
        
        # Chat history scroll view
        self.scroll_view = ScrollView(
            size_hint=(1, None),
            height=Window.height * 0.6,
            pos_hint={'center_x': 0.5, 'top': 0.85}
        )
        
        # This will hold our chat bubbles
        self.chat_layout = GridLayout(
            cols=1,
            spacing=dp(15),
            padding=[dp(10), dp(10), dp(10), dp(20)],
            size_hint_y=None
        )
        self.chat_layout.bind(minimum_height=self.chat_layout.setter('height'))
        
        self.scroll_view.add_widget(self.chat_layout)
        self.main_layout.add_widget(self.scroll_view)
        
        # Input area with fixed position
        input_area = BoxLayout(
            orientation='horizontal',
            size_hint=(1, None),
            height=dp(60),
            padding=[dp(10), dp(5)],
            spacing=dp(10),
            pos_hint={'center_x': 0.5, 'y': 0.02}
        )
        
        # Text input
        self.text_input = TextInput(
            hint_text=tr('type_message_here'),
            size_hint=(0.8, None),
            height=dp(50),
            multiline=False,
            padding=[dp(10), dp(10), dp(10), 0],
            font_size=dp(16)
        )
        self.text_input.bind(on_text_validate=self.send_text_message)
        
        # Container for the send button
        send_container = BoxLayout(
            orientation='vertical',
            size_hint=(0.2, None),
            height=dp(50)
        )
        
        # Create a custom button class that combines ButtonBehavior with BoxLayout
        from kivy.uix.behaviors import ButtonBehavior
        
        class IconButton(ButtonBehavior, BoxLayout):
            def __init__(self, **kwargs):
                super(IconButton, self).__init__(**kwargs)
                self.orientation = 'vertical'
                
                # Draw border and background
                with self.canvas.before:
                    Color(0.36, 0.56, 0.85, 1)  # Blue border color matching send icon
                    self.border = RoundedRectangle(pos=self.pos, size=self.size, radius=[dp(8)])
                    Color(1, 1, 1, 1)  # White background
                    border_width = dp(2)
                    self.bg = RoundedRectangle(
                        pos=(self.x + border_width, self.y + border_width),
                        size=(self.width - 2*border_width, self.height - 2*border_width),
                        radius=[dp(6)]
                    )
                self.bind(pos=self._update_rect, size=self._update_rect)
            
            def _update_rect(self, *args):
                self.border.pos = self.pos
                self.border.size = self.size
                border_width = dp(2)
                self.bg.pos = (self.x + border_width, self.y + border_width)
                self.bg.size = (self.width - 2*border_width, self.height - 2*border_width)
                
            def on_press(self):
                # Change background color when pressed
                self.canvas.before.clear()
                with self.canvas.before:
                    Color(0.36, 0.56, 0.85, 1)  # Blue border color matching send icon
                    self.border = RoundedRectangle(pos=self.pos, size=self.size, radius=[dp(8)])
                    Color(0.9, 0.9, 0.9, 1)  # Gray background for pressed state
                    border_width = dp(2)
                    self.bg = RoundedRectangle(
                        pos=(self.x + border_width, self.y + border_width),
                        size=(self.width - 2*border_width, self.height - 2*border_width),
                        radius=[dp(6)]
                    )
                    
            def on_release(self):
                # Restore original background color
                self.canvas.before.clear()
                with self.canvas.before:
                    Color(0.36, 0.56, 0.85, 1)  # Blue border color matching send icon
                    self.border = RoundedRectangle(pos=self.pos, size=self.size, radius=[dp(8)])
                    Color(1, 1, 1, 1)  # White background
                    border_width = dp(2)
                    self.bg = RoundedRectangle(
                        pos=(self.x + border_width, self.y + border_width),
                        size=(self.width - 2*border_width, self.height - 2*border_width),
                        radius=[dp(6)]
                    )
        
        # Create our custom button
        self.send_btn = IconButton(size_hint=(1, 1))
        
        # Create a centered layout for the icon
        icon_layout = AnchorLayout(
            anchor_x='center',
            anchor_y='center',
            size_hint=(1, 1)
        )
        
        # Create the icon
        self.send_icon = Image(
            source='icons/send.png',
            size_hint=(None, None),
            size=(dp(26), dp(26))
            # No color property to use original icon colors
        )
        
        # Add icon to centered layout
        icon_layout.add_widget(self.send_icon)
        
        # Add the centered layout to the button
        self.send_btn.add_widget(icon_layout)
        
        # Bind to send message function
        self.send_btn.bind(on_release=self.send_text_message)
        
        # Add button to its container
        send_container.add_widget(self.send_btn)
        
        # Add elements to input area
        input_area.add_widget(self.text_input)
        input_area.add_widget(send_container)
        
        self.main_layout.add_widget(input_area)
        
        # Add microphone button between chat and text input
        self.mic_button = PulsingMicButton()
        self.mic_button.pos_hint = {'center_x': 0.5, 'center_y': 0.19} 
        self.mic_button.bind(on_press=self.toggle_listening)
        self.main_layout.add_widget(self.mic_button)
        
        # Process status label
        self.status_label = Label(
            text='',
            font_size=dp(14),
            italic=True,
            color=(0.5, 0.5, 0.5, 1),
            size_hint=(1, None),
            height=dp(20),
            pos_hint={'center_x': 0.5, 'center_y': 0.17}
        )
        self.main_layout.add_widget(self.status_label)
        
        # Add a welcome message from the AI after a small delay
        Clock.schedule_once(self.add_welcome_message, 0.5)
        
        # Bind to language changes for updating text
        self.language_manager.bind(current_language=self._update_language)
        
        # Now that all UI elements are created, we can call update_theme
        self.update_theme()
        
    def update_theme(self, *args):
        """Override to update specific UI elements for this screen"""
        # First call parent's update_theme to handle basic elements
        super(VoiceScreen, self).update_theme(*args)

        # Update colors based on theme
        colors = self.theme_manager.get_colors()
        is_dark = self.theme_manager.is_dark_mode

        # Update title and subtitle colors
        self.title_label.color = colors.get('primary', (0.2, 0.4, 0.8, 1))
        self.subtitle_label.color = colors['text_secondary'] if 'text_secondary' in colors else (0.5, 0.5, 0.5, 1)

        # Update status label
        self.status_label.color = colors['text_secondary'] if 'text_secondary' in colors else (0.5, 0.5, 0.5, 1)

        # Update the send icon color based on theme
        if hasattr(self, 'send_icon'):
            # Don't set any color to preserve the original icon colors
            pass

        # Update text input colors for dark/light theme
        self.text_input.background_color = colors['input_bg']
        self.text_input.foreground_color = colors['text']
        self.text_input.cursor_color = colors['primary']
        
        # Update chat bubbles if any exist
        for child in self.chat_layout.children:
            if isinstance(child, ChatBubble) and hasattr(child, 'update_theme'):
                child.update_theme(is_dark)

    def _update_send_button(self, instance, value):
        """Keep the send icon properly positioned within the button"""
        # The RelativeLayout already handles proper positioning
        pass

    def _update_language(self, *args):
        """Update all UI text based on the current language"""
        # Update static UI elements
        self.title_label.text = tr('medical_assistant')
        self.subtitle_label.text = tr('ask_about_medication')
        self.text_input.hint_text = tr('type_message_here')
        self.send_btn.text = tr('send')
        
        # Update welcome message if it hasn't been sent yet
        if not self.chat_layout.children:
            Clock.schedule_once(self.add_welcome_message, 0.1)

    def add_welcome_message(self, dt=None):
        """Add an initial welcome message from the AI assistant"""
        if self.medication_context:
            welcome_text = f"Hello! I see you're asking about {self.medication_context}. How can I help you with this medication today?"
        else:
            welcome_text = tr('welcome_message')
        
        self.add_message(welcome_text, is_user=False)

    def set_medication_context(self, medication_name):
        """Set context about a specific medication"""
        self.medication_context = medication_name
        
        # If we already have messages, add a new one about the medication
        if self.chat_layout.children:
            self.add_message(f"I see you want to know more about {medication_name}. What would you like to know about this medication?", is_user=False)
    
    def add_message(self, text, is_user=True):
        """Add a message bubble to the chat"""
        # Create a new chat bubble
        bubble = ChatBubble(text, is_user=is_user)
        
        # Add to the chat layout at the bottom
        self.chat_layout.add_widget(bubble)
        
        # Scroll to the bottom to see the new message
        Clock.schedule_once(lambda dt: self._scroll_to_bottom(), 0.1)
    
    def _scroll_to_bottom(self):
        """Scroll the chat view to the bottom"""
        if self.chat_layout.height > self.scroll_view.height:
            self.scroll_view.scroll_y = 0

    def toggle_listening(self, instance):
        """Toggle voice listening mode"""
        if not self.ai_assistant:
            self.status_label.text = tr('assistant_not_available')
            self.mic_button.state = 'normal'
            return
        
        if self.is_listening:
            # Stop listening
            self.is_listening = False
            self.mic_button.state = 'normal'
            self.status_label.text = "Processing..."
        else:
            # Start listening
            self.is_listening = True
            self.mic_button.state = 'down'
            self.status_label.text = "Listening..."
            
            # Start the speech recognition process
            self._start_voice_input()
    
    def _start_voice_input(self):
        """Start the speech recognition process in a separate thread"""
        try:
            if self.ai_assistant:
                # Monitor the AI assistant's is_listening property
                def check_listening_status(dt):
                    try:
                        if not self.ai_assistant.is_listening:
                            # Speech recognition completed
                            self.is_listening = False
                            self.mic_button.state = 'normal'
                            
                            # Safety check to ensure we don't access attributes that don't exist
                            if hasattr(self.ai_assistant, 'response_text'):
                                response_text = self.ai_assistant.response_text
                                
                                if (response_text.startswith("I couldn't understand") or 
                                    response_text.startswith("I didn't hear") or
                                    response_text.startswith("Error")):
                                    # Error in speech recognition
                                    self.status_label.text = response_text
                                    Clock.schedule_once(lambda dt: setattr(self.status_label, 'text', ''), 3)
                                elif hasattr(self.ai_assistant, 'recognized_text') and self.ai_assistant.recognized_text:
                                    # Add the recognized text as a user message
                                    self.add_message(self.ai_assistant.recognized_text, is_user=True)
                                    
                                    # Process with AI and add response
                                    self._process_ai_response()
                            return False  # Stop checking
                        return True  # Continue checking
                    except Exception as e:
                        print(f"Error in check_listening_status: {e}")
                        self.status_label.text = "An error occurred while listening"
                        self.is_listening = False
                        self.mic_button.state = 'normal'
                        return False  # Stop checking on error
                
                # Start the speech recognition with error handling
                try:
                    self.ai_assistant.start_voice_input()
                except Exception as e:
                    print(f"Error starting voice input: {e}")
                    self.status_label.text = "Could not start speech recognition"
                    self.is_listening = False
                    self.mic_button.state = 'normal'
                    return
                
                # Check status periodically until no longer listening
                Clock.schedule_interval(check_listening_status, 0.5)
            else:
                # Handle case when AI assistant is not available
                self.status_label.text = "Speech recognition not available"
                self.is_listening = False
                self.mic_button.state = 'normal'
                
                # Add a fallback message in the chat
                self.add_message("Sorry, I couldn't access the speech recognition system. Please type your message instead.", is_user=False)
        except Exception as e:
            print(f"Error in _start_voice_input: {e}")
            self.status_label.text = "An error occurred"
            self.is_listening = False
            if hasattr(self, 'mic_button'):
                self.mic_button.state = 'normal'
    
    def _process_voice_input(self, recognized_text):
        """Process the recognized text from voice input"""
        if not recognized_text:
            self.add_message("I didn't hear anything. Please try again.", is_user=False)
            return
            
        # Add the user's message to the chat
        self.add_message(recognized_text, is_user=True)
        
        if self.ai_assistant:
            # Check for special navigation commands before processing with AI
            navigation_command = self._check_for_navigation_command(recognized_text)
            if navigation_command:
                self._handle_navigation_command(navigation_command, recognized_text)
            else:
                # Process with AI
                self.ai_assistant.process_text_input(recognized_text)
                self._process_ai_response()
        else:
            # Fallback if no AI assistant
            self.add_message("AI Assistant module is not available. Please check if dependencies are installed.", is_user=False)
            
    def send_text_message(self, instance):
        """Send a text message from the input field"""
        # Get text and clear input field
        text = self.text_input.text.strip()
        self.text_input.text = ''
        
        if not text:
            return
        
        # Add message to chat
        self.add_message(text, is_user=True)
        
        if self.ai_assistant:
            # Check for special navigation commands before processing with AI
            navigation_command = self._check_for_navigation_command(text)
            if navigation_command:
                self._handle_navigation_command(navigation_command, text)
            else:
                # Process with AI
                self.ai_assistant.process_text_input(text)
                self._process_ai_response()
        else:
            # Fallback if no AI assistant
            self.add_message("AI Assistant module is not available. Please check if dependencies are installed.", is_user=False)
    
    def _on_reminder_event_change(self, instance, value):
        """Handle changes to the create_reminder_event property"""
        if not value:
            return
            
        print(f"Reminder event triggered: {value}")
        
        try:
            # Parse the reminder data
            import json
            reminder_data = json.loads(value)
            
            # Reset the event to prevent duplicate reminders
            instance.create_reminder_event = ''
            
            # Create the reminder
            self.add_message("I'm creating a medication reminder for you now...", is_user=False)
            self._create_reminder_from_ai(reminder_data)
            
        except Exception as e:
            print(f"Error processing reminder event: {e}")
            import traceback
            traceback.print_exc()
            self.add_message(f"I couldn't create the reminder: {e}", is_user=False)
    
    def _check_for_navigation_command(self, text):
        """Check if the user is requesting to navigate to a specific screen"""
        text = text.lower()
        
        # Check for navigation to reminders screen
        if any(phrase in text for phrase in [
            'go to reminder', 'go to reminders', 'show reminder', 'show reminders',
            'open reminder', 'open reminders', 'view reminder', 'view reminders',
            'take me to reminder', 'take me to reminders', 'navigate to reminder', 'navigate to reminders'
        ]):
            return 'reminder'
        
        # Check for navigation to home screen
        if any(phrase in text for phrase in [
            'go to home', 'go home', 'show home', 'open home', 'view home',
            'take me to home', 'navigate to home', 'return to home', 'back to home'
        ]):
            return 'home'
        
        return None
    
    def _handle_navigation_command(self, screen_name, original_text):
        """Handle a navigation command to a specific screen"""
        app = App.get_running_app()
        
        # Check if the requested screen exists in the screen manager
        if screen_name in app.root.screen_names:
            # Add a confirmation message
            self.add_message(f"Navigating to {screen_name.title()} screen...", is_user=False)
            
            # Navigate to the requested screen
            app.root.current = screen_name
        else:
            # If screen doesn't exist, process the text normally with AI
            if self.ai_assistant:
                self.ai_assistant.process_text_input(original_text)
                self._process_ai_response()
    
    def _process_ai_response(self):
        """Process the AI response and add it to the chat"""
        if not self.ai_assistant:
            return
        
        self.is_processing = True
        self.status_label.text = ""
        
        # Check for AI response every 0.5 seconds
        def check_response(dt):
            if not self.ai_assistant.is_processing:
                # AI has responded
                self.add_message(self.ai_assistant.response_text, is_user=False)
                self.status_label.text = ''
                self.is_processing = False
                
                # Check if AI wants to create a reminder
                self._check_for_reminder_creation()
                
                return False  # Stop checking
            return True  # Keep checking
        
        # Start checking for response
        Clock.schedule_interval(check_response, 0.5)
        
    def _check_for_reminder_creation(self):
        """Check if the AI assistant wants to create a reminder"""
        # Make sure the AI assistant has the create_reminder_event property
        if not hasattr(self.ai_assistant, 'create_reminder_event'):
            print("AI assistant does not have create_reminder_event property")
            return
            
        # Check if there's a reminder event
        reminder_event = self.ai_assistant.create_reminder_event
        if not reminder_event:
            return
            
        print(f"Detected reminder event: {reminder_event}")
            
        try:
            # Parse the reminder data
            import json
            reminder_data = json.loads(reminder_event)
            print(f"Parsed reminder data: {reminder_data}")
            
            # Reset the event to prevent duplicate reminders
            self.ai_assistant.create_reminder_event = ''
            
            # Create the reminder
            self.add_message("I'm creating a reminder for you now...", is_user=False)
            self._create_reminder_from_ai(reminder_data)
            
        except Exception as e:
            print(f"Error processing reminder creation: {e}")
            self.add_message(f"There was a problem creating your reminder: {e}", is_user=False)
    
    def _create_reminder_from_ai(self, reminder_data):
        """Create a reminder using data extracted by the AI"""
        print(f"Creating reminder with data: {reminder_data}")
        
        # Check if we have a medication reminder manager available
        app = App.get_running_app()
        reminder_screen = None
        
        # First check if reminder screen exists in the screen manager
        if 'reminder' in app.root.screen_names:
            reminder_screen = app.root.get_screen('reminder')
            print("Found existing reminder screen")
        else:
            # Create and add the reminder screen if it doesn't exist
            print("Creating new reminder screen")
            reminder_screen = ReminderScreen(name='reminder')
            app.root.add_widget(reminder_screen)
        
        # Direct access to reminder manager for testing
        from medication_reminder import MedicationReminder
        if not hasattr(reminder_screen, 'reminder_manager') or not reminder_screen.reminder_manager:
            print("Reminder screen doesn't have a working reminder manager, creating one directly")
            try:
                # Try to create a reminder manager directly
                reminder_manager = MedicationReminder()
                reminder_screen.reminder_manager = reminder_manager
            except Exception as import_e:
                print(f"Failed to create MedicationReminder: {import_e}")
                self.add_message("I'm sorry, I couldn't create a reminder because the reminder system is not available.", is_user=False)
                return
            
        print(f"Reminder manager status: {reminder_screen.reminder_manager}")
        
        # Extract reminder data
        medication_name = reminder_data.get('medication')
        dosage = reminder_data.get('dosage')
        frequency = reminder_data.get('frequency')
        duration = reminder_data.get('duration')
        
        print(f"Extracted data: med={medication_name}, dosage={dosage}, freq={frequency}, duration={duration}")
        
        # Check required fields
        if not medication_name or not dosage or not frequency:
            self.add_message("I couldn't create the reminder because some required information is missing.", is_user=False)
            return
        
        # Add the reminder
        try:
            # Explicitly call the add_reminder method with proper arguments
            print("Calling add_reminder method")
            
            reminder_id = reminder_screen.reminder_manager.add_reminder(
                medication_name=medication_name,
                dosage=dosage,
                frequency=frequency,
                duration=duration,
                notes="Created by AI assistant"
            )
            
            print(f"Reminder created with ID: {reminder_id}")
            
            # Confirm success and suggest viewing reminder
            self.add_message("I've successfully created your medication reminder! Would you like to view it now in the Reminders section?", is_user=False)
            
            # Ask if they want to go to the reminder screen
            self.add_message("Say 'show reminders' if you want to see your new reminder.", is_user=False)
            
        except Exception as e:
            print(f"Error adding reminder: {e}")
            import traceback
            traceback.print_exc()
            self.add_message(f"I had trouble creating your reminder: {str(e)}. You can try adding it manually from the Reminders section.", is_user=False)

# Settings Screen - Hides the bar
class SettingsScreen(BaseScreen):
    def __init__(self, **kwargs):
        super(SettingsScreen, self).__init__(**kwargs)
        self.language_manager = LanguageManager()
        self.theme_manager = ThemeManager()
        
        # Main content area
        content_layout = BoxLayout(
            orientation='vertical',
            spacing=dp(20),
            padding=[dp(20), dp(80), dp(20), dp(20)],
            size_hint=(1, 1)
        )
        
        # Settings title
        title = Label(
            text=tr('settings'),
            font_size=dp(24),
            bold=True,
            size_hint=(1, None),
            height=dp(40)
        )
        content_layout.add_widget(title)
        
        # Create settings controls
        # 1. Dark Mode
        dark_mode_row = self._create_setting_row(tr('dark_mode'), True)
        self.dark_switch = dark_mode_row.children[0]  # Get the switch widget
        self.dark_switch.active = self.theme_manager.is_dark_mode
        self.dark_switch.bind(active=self.toggle_dark_mode)
        content_layout.add_widget(dark_mode_row)
        
        # 2. Notifications
        notifications_row = self._create_setting_row(tr('notifications'), True)
        content_layout.add_widget(notifications_row)
        
        # 3. Sound
        sound_row = self._create_setting_row(tr('sound'), True)
        content_layout.add_widget(sound_row)
        
        # 4. Vibration
        vibration_row = self._create_setting_row(tr('vibration'), True)
        content_layout.add_widget(vibration_row)
        
        # 5. Language
        language_row = BoxLayout(
            orientation='horizontal',
            size_hint=(1, None),
            height=dp(50)
        )
        
        lang_label = Label(
            text=tr('language'),
            font_size=dp(18),
            halign='left',
            valign='center',
            size_hint=(0.5, 1)
        )
        lang_label.bind(size=lang_label.setter('text_size'))
        
        # Map language codes to display names
        lang_names = {
            'en': 'English',
            'ro': 'Română',
            'ru': 'Русский'
        }
        
        # Create spinner for language selection
        spinner = Spinner(
            text=lang_names.get(self.language_manager.current_language, 'English'),
            values=[lang_names[code] for code in LANGUAGES],
            size_hint=(0.5, 0.8),
            pos_hint={'center_y': 0.5},
            font_size=dp(16)
        )
        spinner.bind(text=self.on_language_change)
        self.language_spinner = spinner
        
        language_row.add_widget(lang_label)
        language_row.add_widget(spinner)
        content_layout.add_widget(language_row)
        
        # Add logout button at the bottom
        logout_btn = RoundedButton(
            text=tr('logout'),
            size_hint=(0.5, None),
            height=dp(50),
            pos_hint={'center_x': 0.5},
            bg_color=(0.9, 0.3, 0.3, 1),  # Red color
            font_size=dp(18)
        )
        logout_btn.bind(on_release=self.logout)
        self.logout_btn = logout_btn
        
        # Add some spacing
        content_layout.add_widget(Widget(size_hint_y=1))
        content_layout.add_widget(logout_btn)
        
        # Add content to main layout
        self.main_layout.add_widget(content_layout)
        
        # Update theme
        self.update_theme()
    
    def _create_setting_row(self, label_text, default_active=False):
        """Helper method to create a setting row with a label and switch"""
        row = BoxLayout(
            orientation='horizontal',
            size_hint=(1, None),
            height=dp(50)
        )
        
        label = Label(
            text=label_text,
            font_size=dp(18),
            halign='left',
            valign='center',
            size_hint=(0.5, 1)
        )
        label.bind(size=label.setter('text_size'))
        
        switch = Switch(
            active=default_active,
            size_hint=(0.5, 1),
            pos_hint={'center_y': 0.5}
        )
        
        row.add_widget(label)
        row.add_widget(switch)
        return row
    
    def update_theme(self, *args):
        """Update UI based on theme"""
        super(SettingsScreen, self).update_theme(*args)
        
        # Update dark mode switch
        if hasattr(self, 'dark_switch'):
            self.dark_switch.active = self.theme_manager.is_dark_mode
    
    def toggle_dark_mode(self, switch, value):
        """Toggle dark mode"""
        self.theme_manager.set_dark_mode(value)
    
    def on_language_change(self, spinner, text):
        """Handle language change"""
        # Map display names to language codes
        lang_map = {'English': 'en', 'Română': 'ro', 'Русский': 'ru'}
        lang_code = lang_map.get(text, 'en')
        
        # Update language
        self.language_manager.set_language(lang_code)
        
        # Show message about app restart
        toast = Popup(
            title='',
            content=Label(text="Language changed. App restart recommended."),
            size_hint=(None, None),
            size=(dp(300), dp(100)),
            auto_dismiss=True
        )
        toast.open()
        Clock.schedule_once(lambda dt: toast.dismiss(), 2)
    
    def logout(self, instance):
        """Log out and return to login screen"""
        app = App.get_running_app()
        app.current_user = None
        self.manager.transition = SlideTransition(direction='right')
        self.manager.current = 'login'

    def _update_language_ai_assistant(self, *args):
        try:
            if hasattr(self, 'ai_assistant_label'):
                self.ai_assistant_label.text = tr('ask_ai_assistant')
            if hasattr(self, 'ai_description_label'):
                self.ai_description_label.text = tr('ai_assistant_description')
            if hasattr(self, 'back_to_home_btn'): 
                self.back_to_home_btn.text = tr('back_to_home')
            if hasattr(self, 'medication_query_input'):
                self.medication_query_input.hint_text = tr('type_your_question_here')
            if hasattr(self, 'submit_query_btn'):
                self.submit_query_btn.text = tr('ask_ai')
        except Exception as e:
            print(f"Error updating language in AIAssistant: {e}")

class HomeScreen(Screen):
    def __init__(self, **kwargs):
        super(HomeScreen, self).__init__(**kwargs)
        self.theme_manager = ThemeManager()
        
        # Main layout with theme-based background
        main_layout = FloatLayout()
        
        # Set background color based on theme
        with main_layout.canvas.before:
            self.bg_color = Color(1, 1, 1, 1)  # Default color, will be updated by theme
            self.bg_rect = Rectangle(pos=main_layout.pos, size=main_layout.size)
            main_layout.bind(pos=self._update_rect, size=self._update_rect)
        
        # Store the username label for later reference
        self.username_label = Label(
            text='Username',  # This will be updated with actual username
            font_size=dp(18),
            color=(0.1, 0.1, 0.1, 1),  # Will be updated by theme
            bold=True,
            size_hint=(None, None),
            size=(dp(200), dp(40)),
            pos_hint={'center_x': 0.5, 'center_y': 0.5}
        )
        
        # Create top bar container
        self.top_container = FloatLayout(size_hint=(1, None), height=dp(60))
        self.top_container.pos_hint = {'x': 0, 'top': 1}  # Position at top
        
        # Create top bar background with theme-based color
        with self.top_container.canvas.before:
            self.top_shadow_color = Color(0.7, 0.7, 0.7, 0.2)  # Will be updated by theme
            RoundedRectangle(
                pos=(self.top_container.x + dp(4), self.top_container.y - dp(4)),
                size=(self.top_container.width, self.top_container.height),
                radius=[(0, 0, dp(20), dp(20))]
            )
            
            self.top_shadow_color2 = Color(0.75, 0.75, 0.75, 0.5)  # Will be updated by theme
            RoundedRectangle(
                pos=(self.top_container.x + dp(2), self.top_container.y - dp(2)),
                size=(self.top_container.width, self.top_container.height),
                radius=[(0, 0, dp(20), dp(20))]
            )
            
            self.top_bg_color = Color(0.92, 0.92, 0.92, 1)  # Will be updated by theme
            self.top_rect = RoundedRectangle(
                pos=(self.top_container.x, self.top_container.y),
                size=(self.top_container.width, self.top_container.height),
                radius=[(0, 0, dp(20), dp(20))]
            )
            self.top_container.bind(pos=self._update_top_rect, size=self._update_top_rect)
        
        # Add username label to top bar
        self.top_container.add_widget(self.username_label)
        
        # Add top container to main layout
        main_layout.add_widget(self.top_container)
        
        # Create bottom navigation bar container
        self.nav_container = FloatLayout(size_hint=(1, None), height=dp(80))
        self.nav_container.pos_hint = {'x': 0, 'y': 0}  # Position at bottom
        
        # Create rounded navigation bar background with theme-based colors
        with self.nav_container.canvas.before:
            self.nav_shadow_color = Color(0.7, 0.7, 0.7, 0.2)  # Will be updated by theme
            RoundedRectangle(
                pos=(self.nav_container.x + dp(4), self.nav_container.y - dp(4)),
                size=(self.nav_container.width, self.nav_container.height),
                radius=[(dp(20), dp(20), 0, 0)]
            )
            
            self.nav_shadow_color2 = Color(0.75, 0.75, 0.75, 0.5)  # Will be updated by theme
            RoundedRectangle(
                pos=(self.nav_container.x + dp(2), self.nav_container.y - dp(2)),
                size=(self.nav_container.width, self.nav_container.height),
                radius=[(dp(20), dp(20), 0, 0)]
            )
            
            self.nav_bg_color = Color(0.92, 0.92, 0.92, 1)  # Will be updated by theme
            self.nav_rect = RoundedRectangle(
                pos=(self.nav_container.x, self.nav_container.y),
                size=(self.nav_container.width, self.nav_container.height),
                radius=[(dp(20), dp(20), 0, 0)]
            )
            self.nav_container.bind(pos=self._update_nav_rect, size=self._update_nav_rect)
        
        # Create navigation bar
        nav_bar = BoxLayout(
            size_hint=(0.95, 0.9),
            pos_hint={'center_x': 0.5, 'center_y': 0.5},
            spacing=dp(10),
            padding=[dp(10), dp(5), dp(10), dp(5)]
        )
        
        # Create regular navigation buttons with icons
        buttons = [
            {'icon': 'home', 'text': 'Home'},
            {'icon': 'reminder', 'text': 'Reminder'},
            {'icon': 'mediscan', 'text': 'MediScan'},
            {'icon': 'voice', 'text': 'Voice'},
            {'icon': 'settings', 'text': 'Settings'}
        ]
        
        # Add all buttons to the navigation bar
        for i, btn in enumerate(buttons):
            button = IconButton(
                icon_type=btn['icon'],
                text=btn['text']
            )
            nav_bar.add_widget(button)
        
        # Add navigation bar to container
        self.nav_container.add_widget(nav_bar)
        
        # Add navigation container to main layout
        main_layout.add_widget(self.nav_container)
        
        # Add welcome message in the center
        welcome_layout = AnchorLayout(anchor_x='center', anchor_y='center')
        self.welcome_label = Label(
            text='Home Page',
            font_size=dp(24),
            color=(0.2, 0.2, 0.2, 1)  # Will be updated by theme
        )
        welcome_layout.add_widget(self.welcome_label)
        main_layout.add_widget(welcome_layout)
        
        self.add_widget(main_layout)
        
        # Update theme initially
        self.update_theme()
        
        # Bind to theme changes
        self.theme_manager.bind(is_dark_mode=self.update_theme)
    
    def update_theme(self, *args):
        """Update colors based on current theme"""
        colors = self.theme_manager.get_colors()
        is_dark = self.theme_manager.is_dark_mode
        
        # Update background color
        self.bg_color.rgba = colors['background']
        
        # Update text colors
        self.username_label.color = colors['text']
        self.welcome_label.color = colors['text']
        
        # Update top bar colors
        if is_dark:
            self.top_shadow_color.rgba = (0.1, 0.1, 0.1, 0.4)
            self.top_shadow_color2.rgba = (0.1, 0.1, 0.1, 0.6)
            self.top_bg_color.rgba = (0.2, 0.2, 0.2, 1)
        else:
            self.top_shadow_color.rgba = (0.7, 0.7, 0.7, 0.2)
            self.top_shadow_color2.rgba = (0.75, 0.75, 0.75, 0.5)
            self.top_bg_color.rgba = (0.92, 0.92, 0.92, 1)
        
        # Update navigation bar colors
        if is_dark:
            self.nav_shadow_color.rgba = (0.1, 0.1, 0.1, 0.4)
            self.nav_shadow_color2.rgba = (0.1, 0.1, 0.1, 0.6)
            self.nav_bg_color.rgba = (0.2, 0.2, 0.2, 1)
        else:
            self.nav_shadow_color.rgba = (0.7, 0.7, 0.7, 0.2)
            self.nav_shadow_color2.rgba = (0.75, 0.75, 0.75, 0.5)
            self.nav_bg_color.rgba = (0.92, 0.92, 0.92, 1)
    
    def _update_rect(self, instance, value):
        self.bg_rect.pos = instance.pos
        self.bg_rect.size = instance.size
    
    def _update_nav_rect(self, instance, value):
        self.nav_rect.pos = (instance.x, instance.y)
        self.nav_rect.size = (instance.width, instance.height)
    
    def _update_top_rect(self, instance, value):
        self.top_rect.pos = (instance.x, instance.y)
        self.top_rect.size = (instance.width, instance.height)
    
    def update_username(self, username):
        self.username_label.text = f"Welcome, {username}!"
        # Make sure the username label is visible and properly positioned
        if hasattr(self, 'top_container'):
            self.username_label.pos_hint = {'center_x': 0.5, 'center_y': 0.5}
            self.username_label.size_hint = (None, None)
            self.username_label.size = (dp(250), dp(40))
            # Adjust font size for longer names
            if len(username) > 10:
                self.username_label.font_size = dp(16)
            else:
                self.username_label.font_size = dp(18)
    
    def navigate_to(self, screen_type):
        print(f"Navigating to {screen_type} screen")
        app = App.get_running_app()
        
        # Check if screen exists first
        if screen_type == 'home':
            # Already on home screen, no need to navigate
            return
        elif screen_type not in app.root.screen_names:
            # Create the screen if it doesn't exist
            if screen_type == 'reminder':
                app.root.add_widget(ReminderScreen(name='reminder'))
            elif screen_type == 'mediscan':
                app.root.add_widget(MediScanScreen(name='mediscan'))
            elif screen_type == 'voice':
                app.root.add_widget(VoiceScreen(name='voice'))
            elif screen_type == 'settings':
                app.root.add_widget(SettingsScreen(name='settings'))
        
        # Navigate to the screen
        app.root.current = screen_type
    
    def logout(self, instance):
        # Clear current user and go back to login screen
        app = App.get_running_app()
        app.current_user = None
        self.manager.transition = SlideTransition(direction='right')
        self.manager.current = 'login'

    def apply_theme(self):
        """Apply the current theme to the UI"""
        is_dark = self.theme_manager.is_dark_mode
        
        # Update background color
        if is_dark:
            self.main_layout.canvas.before.clear()
            with self.main_layout.canvas.before:
                Color(0.1, 0.1, 0.1, 1)  # Very dark gray, almost black
                self.bg_rect = Rectangle(pos=self.main_layout.pos, size=self.main_layout.size)
                self.main_layout.bind(pos=self._update_bg, size=self._update_bg)
        else:
            self.main_layout.canvas.before.clear()
            with self.main_layout.canvas.before:
                Color(0.95, 0.95, 0.95, 1)  # Light gray
                self.bg_rect = Rectangle(pos=self.main_layout.pos, size=self.main_layout.size)
                self.main_layout.bind(pos=self._update_bg, size=self._update_bg)

    def update_card_data(self, reminder_data):
        """Update card data while preserving state"""
        # Store original state
        original_doses_taken = getattr(self, 'doses_taken', 0)
        original_next_dose_time = getattr(self, 'next_dose_time', None)
        
        # Update with new data but preserve key state
        self.reminder_data = reminder_data
        self.reminder_id = reminder_data.get('id', '')
        
        # Recalculate frequency and duration info
        self.frequency = reminder_data.get('frequency', 'Once daily')
        self.duration = int(reminder_data.get('duration', 1))
        
        # Update UI elements if they exist
        if hasattr(self, 'title'):
            self.title.text = reminder_data.get('medication_name', 'Medication')
        
        if hasattr(self, 'dosage_value'):
            self.dosage_value.text = reminder_data.get('dosage', 'N/A')
            
        if hasattr(self, 'frequency_value'):
            self.frequency_value.text = self.frequency
            
        if hasattr(self, 'duration_value'):
            self.duration_value.text = f"{self.duration} day{'s' if self.duration > 1 else ''}"
        
        # Preserve doses taken - use the higher of the two values
        new_doses_taken = int(reminder_data.get('doses_taken', 0))
        self.doses_taken = max(original_doses_taken, new_doses_taken)
        
        if hasattr(self, 'doses_value'):
            self.doses_value.text = f"{self.doses_taken}/{self.total_doses} taken"
        
        # Preserve next dose time if it exists
        if original_next_dose_time and isinstance(original_next_dose_time, datetime):
            # Keep existing next_dose_time to avoid resetting countdown
            self.next_dose_time = original_next_dose_time
        elif reminder_data.get('next_time') and isinstance(reminder_data['next_time'], datetime):
            # Use the new next_time if no existing one
            self.next_dose_time = reminder_data['next_time']
            
        # Update cooldown status
        self.check_cooldown_status()

    def _create_buttons_layout(self, reminder_data):
        """Create the button layout for edit and delete buttons"""
        # Create a row for buttons
        buttons_row = BoxLayout(
            orientation='horizontal',
            size_hint=(1, None),
            height=dp(50),
            spacing=dp(10),
            padding=[dp(0), dp(5), dp(0), dp(5)]
        )
        
        # Edit button with improved styling
        edit_btn = RoundedButton(
            text=tr('edit'),
            size_hint=(0.5, 1),
            bg_color=(0.4, 0.6, 0.8, 1),  # Blue color
            font_size=dp(16),
            bold=True
        )
        edit_btn.bind(on_release=lambda x: self.edit_reminder())
        
        # Delete button with improved styling
        delete_btn = RoundedButton(
            text=tr('delete'),
            size_hint=(0.5, 1),
            bg_color=(0.8, 0.4, 0.4, 1),  # Red color
            font_size=dp(16),
            bold=True
        )
        delete_btn.bind(on_release=lambda x: self.delete_reminder())
        
        buttons_row.add_widget(edit_btn)
        buttons_row.add_widget(delete_btn)
        return buttons_row

    def _create_take_button(self):
        """Create the take now button with improved styling"""
        # Container for the take button to improve padding and alignment
        take_btn_container = BoxLayout(
            orientation='vertical',
            size_hint=(1, None),
            height=dp(60),
            padding=[dp(0), dp(5), dp(0), dp(5)]
        )
        
        # Create the take now button with improved styling
        take_btn = RoundedButton(
            text=tr('take_now'),
            size_hint=(1, 1),
            bg_color=(0.2, 0.8, 0.2, 1),  # Green color
            font_size=dp(16),
            bold=True
        )
        take_btn.bind(on_release=lambda x: self.take_dose())
        
        take_btn_container.add_widget(take_btn)
        return take_btn_container

    def _update_send_button(self, instance, value):
        """This method is no longer used as the icon is centered using pos_hint"""
        pass